
# 实体数据结构和过程机制


tags: #日期/2023-01-31 #类型/想法 #类型/笔记 #内容/过程机制 



> 节选自现有的一个项目工程，部分有删减。


# 过程机制



## 处理和执行实体过程

![[处理和执行实体过程.svg]]



![[模型实体过程样例.svg]]

## 实体结构图与运作过程

![[实体结构图与运作过程.svg]]


## 实体结构

![[实体结构.svg]]


## 实体过程结构示例图

![[实体过程结构示例图.svg]]

## 实体数据结构

![[实体数据结构.svg]]






# 实体数据结构和过程流处理相关的代码



## 初始状态实体数据结构相关的代码：



### entityData_BI1111.py



```python
"""
实体数据之模型BI1111
"""
# import here

entityData_BI1111 = dict(
    attribute=dict(
        id=2000,
        entity_name="entity_BI1111",
        text_name="模型算法BI1111",
        node_type={"container node", "process node"},
        content_type={"model content"},
    ),
    execute="Processor.process",
    content="content_BI1111",
    container=list([
        dict(
            node=dict(
                name="node_START",
                content="entity_START",
                process=list([
                    dict(
                        arrow=dict(
                            condition="True",
                            direction="node_01",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_01",
                content="entity_EBisv",
                process=list([
                    dict(
                        arrow=dict(
                            condition="A.BB.isv.any() != A_data.BB[env['round']-1]['dataBB'].isv.any()",
                            direction="node_02",
                        ),
                    ),
                    dict(
                        arrow=dict(
                            condition="A.BB.isv.all() == A_data.BB[env['round']-1]['dataBB'].isv.all()",
                            direction="node_03",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_02",
                content="entity_IBisv",
                process=list([
                    dict(
                        arrow=dict(
                            condition="A.BB.isv.any() != A_data.BB[env['round']-1]['dataBB'].isv.any()",
                            direction="node_02",
                        ),
                    ),
                    dict(
                        arrow=dict(
                            condition="A.BB.isv.all() == A_data.BB[env['round']-1]['dataBB'].isv.all()",
                            direction="node_03",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_03",
                content="entity_EBilq",
                process=list([
                    dict(
                        arrow=dict(
                            condition="A.BB.ilq.any() != A_data.BB[env['round']-1]['dataBB'].ilq.any()",
                            direction="node_04",
                        ),
                    ),
                    dict(
                        arrow=dict(
                            condition="A.BB.ilq.all() == A_data.BB[env['round']-1]['dataBB'].ilq.all()",
                            direction="node_END",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_04",
                content="entity_IBilq",
                process=list([
                    dict(
                        arrow=dict(
                            condition="A.BB.ilq.any() != A_data.BB[env['round']-1]['dataBB'].ilq.any()",
                            direction="node_04",
                        ),
                    ),
                    dict(
                        arrow=dict(
                            condition="A.BB.ilq.all() == A_data.BB[env['round']-1]['dataBB'].ilq.all()",
                            direction="node_END",
                        ),
                    ),
                    # dict( #HACK 先暂时不考虑，因为这个过程还未完成。目前为了测试调度框架。
                    #     direction="entity_IBbrp",
                    #     condition=" TODO ",
                    # ),
                ]),
            ),
        ),
        # dict(#HACK 先暂时不考虑，因为这个过程还未完成。目前为了测试调度框架。
        #     node=dict(
        #         name="node_05",
        #         content="entity_IBbrp",
        #         process=list([
        #         ]),
        #     ),
        # ),
        dict(
            node=dict(
                name="node_END",
                content="entity_END",
                process=list([
                    dict(
                        arrow=None,
                    ),
                ]),
            ),
        ),
    ])
)

```





### entityData_START.py



```python
"""
开始实体
"""

entityData_START = dict(
    attribute=dict(
        id=0000,
        entity_name="entity_START",
        text_name="开始",
        node_type={"process node"},
        content_type={"process content"},
    ),
    execute="Processor.process",
    content=None,
    container=None,
)

```



### entityData_END.py



```python
"""
结束实体
"""

entityData_START = dict(
    attribute=dict(
        id=9999,
        entity_name="entity_END",
        text_name="结束",
        node_type={"process node"},
        content_type={"process content"},
    ),
    execute="Processor.process",
    content=None,
    container=None,
)
```



### entityData_IBisv.py

```python

# import here

entityData_InterBankInsolvent = dict(
    attribute=dict(
        id=2020,
        entity_name="entity_IBisv",
        text_name="XXXXXXXXXX",
        node_type={"container node", "process node"},
        content_type={"algorithm content"},
    ),
    execute="Processor.process",
    content=None,  # TODO等需要的时候再写
    container=list([
        dict(
            node=dict(
                name="node_START",
                content="entity_START",
                process=list([
                    dict(
                        arrow=dict(
                            condition="True",
                            direction="node_01",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_01",
                content="entity_IBisvc",
                process=list([
                    dict(
                        arrow=dict(
                            condition="True",
                            direction="node_02",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_02",
                content="entity_IBisvs",
                process=list([
                    dict(
                        arrow=dict(
                            condition="True",
                            direction="node_END",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_END",
                content="entity_END",
                process=list([
                    dict(
                        arrow=None,
                    ),
                ]),
            ),
        ),
    ]),
)

```





### entityData_IBisvs.py

```python


# import here

pass  # end import

entityData_IBisvs = dict(
    attribute=dict(
        id=4020,
        entity_name="entity_IBisvs",
        text_name="XXXXXXXX",
        node_type={"content node"},
        content_type={"algorithm content"},
    ),
    execute="content_IBisvs",
    content=None,
    container=None,
)

```



### entityData_IBisvc.py



```python


# import here

pass  # end import

entityData_IBisvc = dict(
    attribute=dict(
        id=4030,
        entity_name="entity_IBisvc",
        text_name="XXXXXXXXXX",
        node_type={"content node"},
        content_type={"algorithm content"},
    ),
    execute="content_IBisvc",
    content=None,
    container=None,
)

```















## 构建实体过程相关的代码



### builder.py





```python
"""
构建机
"""

from .import Any, deepcopy, re
from .core.define.define_type import EnvironmentVariableType
from .core.define.define_environmentVariables import env
from .core.define.define_entity import Entity
from .core.define.define_component import AttributeComponent
from .core.operations.processor import Processor  # NOTE 动态导入，严禁删除
from .tools.tools import Tools

pass  # end import


class Builder:
    """构建机"""

    @classmethod
    def build_entities(cls, env: EnvironmentVariableType = env):
        """
        构建实体众

        Args:
            env(EnvironmentVariableType): 环境变量集

        Returns:
            algorithmEntities: 算法实体列表, algorithmContents: 算法内容列表

        """

        ## 导入相关模块（#NOTE 动态导入，严禁删除）
        ## 导入模型、过程、算法初始态实体之数据内容
        import .models.entities_data
        env['list_entityData'] = Tools.import_modules_from_package(env['folderpath_import_modules'], r"entityData_")
        ## 导入模型、过程、算法内容
        import .models.contents
        env['list_algorithm_contents'] = Tools.import_modules_from_package(env['folderpath_import_modules'], r"content_")

        ## 生成算法内容列表
        algorithmContents = env['list_algorithm_contents']

        ## 根据算法实体数据列表之数据，生成相应的算法实体对象，然后组成算法实体列表
        algorithmEntities = {}
        for entityData_name, entityData in env['list_entityData'].items():
            algorithmEntity = Entity(entityData)  # 构造每个实体
            algorithmEntities[entityData_name] = deepcopy(algorithmEntity)
            pass  # for

        ## 补充算法实体之特征
        for algorithmEntity in algorithmEntities.values():
            if algorithmEntity.attribute.content_name is None:
                algorithmEntity.attribute.content_name = algorithmEntity.content  # 内容名称`content_name`
            pass  # for

        ## 生成节点实体列表
        for algorithmEntity in algorithmEntities.values():
            nodeEntities = {}
            if algorithmEntity.container is not None:
                for node in algorithmEntity.container:
                    if node is not None:
                        ## 构建一个节点实体
                        nodeEntity = deepcopy(algorithmEntities[node['node']['content']])  # 先直接复制以继承该节点实体对应的算法实体之值，然后再改造
                        nodeEntity.attribute.id = None
                        nodeEntity.attribute.entity_name = node['node']['name']  # 设置节点之名称
                        nodeEntity.attribute.content_name = None
                        nodeEntity.attribute.text_name = None
                        nodeEntity.attribute.other['process_state'] = "has not process"  # 设置节点之处理状态
                        nodeEntity.process = node['node']['process']
                        nodeEntity.execute = None
                        nodeEntity.container = None
                        nodeEntity.content = node['node']['content']  # 设置节点之内容
                        ## 生成节点实体列表
                        nodeEntities[node['node']['name']] = nodeEntity
                        pass  # if
                    pass  # for
                ## 构建容器：将容器之值替换成节点实体字典列表之值
                algorithmEntity.container = nodeEntities
                del nodeEntities

                ## 构建过程：将过程之值改成箭头实体列表之值
                for node in algorithmEntity.container.values():
                    arrowEntities = []
                    if node.process is not None:
                        for idx_arrow, arrow in enumerate(node.process):
                            if arrow['arrow'] is not None:
                                arrowEntities.append(arrow['arrow'])
                        algorithmEntity.container[node.attribute.entity_name].process = arrowEntities
                        del arrowEntities
                    pass  # for

            pass  # for

        ## 装配箭头实体：将过程之箭头实体之方向之值链接至容器之对应的节点实体
        for algorithmEntity in algorithmEntities.values():
            if algorithmEntity.container is not None:
                for node in algorithmEntity.container.values():
                    if node.process is not None:
                        for arrow_value in node.process:
                            arrow_value['direction'] = algorithmEntity.container[arrow_value['direction']]
            pass  # for

        ## 装配节点实体：将容器之节点实体之内容之值链接至对应的算法实体
        for algorithmEntity in algorithmEntities.values():
            if algorithmEntity.container is not None:
                for node in algorithmEntity.container.values():
                    node.content = algorithmEntities[node.content]
            pass  # for

        ## 装配算法实体之内容：将算法实体之内容之值链接至对应的算法内容功能函数
        for algorithmEntity in algorithmEntities.values():
            if (
                    algorithmEntity.attribute.node_type == {"process node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"process node"} and
                    algorithmEntity.attribute.content_type == {"process content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"model content"}
            ):
                if algorithmEntity.content is not None:
                    algorithmEntity.content = algorithmContents[algorithmEntity.content]
                    pass  # if
                pass  # if
            pass  # for

        ## 装配算法实体之执行器：将算法实体之执行器之值链接至对应的算法内容功能函数
        for algorithmEntity in algorithmEntities.values():
            if (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"model content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"process node"} and
                    algorithmEntity.attribute.content_type == {"process content"}
            ):
                if algorithmEntity.execute is not None:
                    algorithmEntity.execute = eval(algorithmEntity.execute)  # 设置执行器之值是处理机
                    pass  # if
                pass  # if
            if (
                    algorithmEntity.attribute.node_type == {"content node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ):
                algorithmEntity.execute = algorithmContents[algorithmEntity.execute]  # 设置执行器之值是具体的算法内容
                pass  # if
            pass  # for

        ## 生成模型节点实体（暨根节点实体，简称模型实体）字典列表
        modelEntities = {}
        for algorithmEntity in algorithmEntities.values():
            if algorithmEntity.attribute.content_type == {"model content"}:
                pattern = r'_'
                ## 构建一个节点实体
                modelEntity = deepcopy(algorithmEntity)  # 先直接复制以继承该节点实体对应的算法实体之值，然后再改造
                modelEntity.attribute.id = None
                modelEntity.attribute.entity_name = "entity_" + re.split(pattern, algorithmEntity.attribute.entity_name)[1]  # 设置节点之名称
                modelEntity.attribute.content_name = None
                modelEntity.attribute.text_name = None
                modelEntity.attribute.other['process_state'] = "has not process"  # 设置节点之处理状态
                modelEntity.process = None
                modelEntity.execute = None
                modelEntity.container = None
                modelEntity.content = algorithmEntity  # 设置节点之内容
                modelEntities[algorithmEntity.attribute.entity_name] = modelEntity
                pass  # if
            pass  # for

        return modelEntities
        pass  # method


    @classmethod
    def build_entity(cls, entityData: Any):  # HACK 无用
        """
        通过实体之数据构造实体对象

        Args:
            entityData: 实体数据

        Returns:
            entity: 实体对象（初始态）
        """
        entity = None
        str_build_specific_entity = "Entity(list_entityData)"
        entity = eval(str_build_specific_entity)
        return entity
        pass  # method

    pass  # class



```





## 处理实体过程相关的代码



### 算法：

特征变量`content_type`表示节点之内容类型。取值如下：
- `content_type = {"process content"}`表示是过程内容节点。目前的过程节点只有两个特殊的节点：开始节点`node_START`、结束节点`node_END`；
- `content_type = {"algorithm content"}`表示是算法内容节点。这类节点承载具体的算法内容；

特征变量`node_type`表示节点之类型。取值表示为集合。集合元素如下：
- `"content node"`表示是内容类型节点；
- `"container node"`表示容器类型节点；
- `"process node"`表示过程类型节点；

特征变量`process_state`表示当前节点处理状态，如果用可视化标记节点颜色表示标记状态，那么：

- 标记是白色`process_state == "has not process"`说明还没处理过该节点，也没有在处理；
- 标记是绿色`process_state == "process now"`说明正在处理该节点；
- 标记是黄色`process_state == "process inner"`说明正在处理该节点之内层节点；
- 标记是红色`process_state == "has processed"`说明已经处理过该节点，但是不表示接下来不会再准备处理该节点；

处理单个节点之过程：

1. 对于准备处理的某一个节点`node_XX`来说，判断其类型：
	- 如果是过程内容节点`node_START`：
	  1. 节点`node_START`标记为绿色；
	  2. 处理节点`node_START`时，标记为红色；
	  3. 跳出到外一层节点`node_XX_outer`；
	- 如果是算法内容和非内容类型的节点（暨非终端节点），则：
	  1. 节点`node_XX`标记为绿色；
	  2. 处理容器内部节点`node_START`（此时意味着处理容器内之内容）；
	  3. 标记`node_XX`为黄色；
	  4. 【步骤1】：根据条件获取`node_XX`之容器之过程之下一个待处理的节点之名称`node_NEXT_name`；
	  5. 判断`node_NEXT_name`是不是结束节点，如果不是就继续，否则跳转到【步骤2】；
	  6. 根据`node_NEXT_name`匹配节点`node_NEXT`；
	  7. 处理容器内部节点`node_NEXT`；
	  8. 跳转到【步骤1】；
	  9. 【步骤2】：处理容器内部节点`node_NEXT`；
	  10. 标记`node_XX`为红色；
	  11. 跳出到外一层节点`node_XX_outer`；
	- 如果是算法内容和内容类型的节点（暨终端节点，承载了具体的算法内容），则：
	  1. 标记为绿色
	  2. 处理该节点；
	  3. 处理之后，标记为红色；
	  4. 跳出到外一层节点`node_XX_outer`；
	- 如果是过程内容节点`node_END`则：
	  1. 节点`node_END`标记为绿色；
	  2. 处理节点`node_END`时，标记为红色；
	  3. 跳出到外一层节点`node_XX_outer`；



### processor.py



```python
"""
处理机。
#NOTE：如果不是因为Python语言会出现循环调用的情况，那么会将这里的一些功能和内容放入`operator`。
"""

from .import dataclass, logging
from .core.define.define_agentDataCollection import AgentDataCollection
from .core.define.define_agents import Agent
from .core.define.define_entity import Entity
from .core.define.define_enum import StateOfScheduleEnum
from .core.operations.collector import Collector
from .core.operations.executer import Executer
from .core.operations.scheduler import Scheduler


@dataclass()
class Processor:
    """
    处理机
    """

    @classmethod
    def process(cls, node: Entity, A: Agent, A_data: AgentDataCollection, para, env):
        """
        处理所有类型的实体。

        TODO：HACK：目前采用的是以栈的形式处理，这样的缺点是受到python自带的栈深度限制。后续方便的话要改成用遍历动态多叉树生成序列的形式处理。
        NOTE：这里略去了功能：对特殊节点调用`Excuter`。因为就目前的程序来说，没必要进一步复杂化，直接在`Processor`内处理即可。

        Args:
            node (Entity): 节点实体（NOTE：本函数中，特指节点实体而非算法实体。算法实体表示`entity`。）
            A (Agent): Agent群变量
            A_data (AgentDataCollection): Agent群变量之数据
            para (dict): 参数变量
            env (dict): 环境变量

        Returns: entity: 算法实体, A: Agent群变量, para: 参数变量, env: 环境变量, A_data: Agent群变量之数据

        """

        ## 如果实体之节点之类型是 content node，且内容之类型是 {"algorithm content"}，则处理：
        if node.attribute.node_type == {"content node"} and node.attribute.content_type == {"algorithm content"}:
            ## 设置临时变量
            b = (A.BB.on | A.BB.off)  # BB示性变量
            ib = (A.BB.on | A.BB.off) & (A.BB.on | A.BB.off).T  # BI示性变量

            ## 执行终端节点内容
            if env['state_of_schedule'] == StateOfScheduleEnum.collecting:
                env = Scheduler.schedule(env, node)
                if env['state_of_schedule'] == StateOfScheduleEnum.running:
                    A = Executer.execute_terminal_entity(A, b, ib, para, env, node)

            ## 收集数据
            A_data, env = Collector.collect(A, A_data, env)

            ## 标记为已经处理过
            node.attribute.other['process_state'] = "has processed"

            pass  # if

        ## 如果实体之节点之类型是 {"process node", "container node"}，且内容之类型是 {"algorithm content"} 或者 {"model content"} ，则处理：
        if (
                node.attribute.node_type == {"process node", "container node"} and node.attribute.content_type == {"algorithm content"}
        ) or (
                node.attribute.node_type == {"process node", "container node"} and node.attribute.content_type == {"model content"}
        ):
            ## 处理容器内之当前节点实体
            node.attribute.other['process_state'] = "process now"  # 标记为正在处理
            entity = node.content  # 获取节点实体对应的算法实体
            inner_node_name = entity.container['node_START'].attribute.entity_name
            inner_node = entity.container[inner_node_name]  # 获取该节点内层之节点
            inner_node, A, A_data, para, env = Executer.execute_branch_entity(inner_node, A, A_data, para, env)  ## 执行开始节点实体
            inner_node.attribute.other['process_state'] = "has processed"
            node.attribute.other['process_state'] == "process inner"  # 标记节点之处理状态为处理内层节点
            inner_forward_node = inner_node.process[0]['direction']  # 获取开始节点之前向节点
            logging.debug("        方向是【节点：%s，算法：%s %s】", inner_forward_node.attribute.entity_name, inner_forward_node.content.attribute.entity_name, inner_forward_node.content.attribute.text_name)

            ## 继续循环处理该节点之内层的前向的节点，直到处理完结束节点为止。
            while not (inner_forward_node.attribute.other['process_state'] == "has processed" and inner_forward_node.attribute.entity_name == "node_END"):
                ## 处理过程之内容（#NOTE：在设计的时候，就应该保证，同一个`arrow`之各个条件里，只能有一个条件是`True`，然后被处理于后续的时候）
                if inner_forward_node.attribute.node_type == {"content node"} and inner_forward_node.attribute.content_type == {"algorithm content"}:
                    inner_forward_node, A, A_data, para, env = Executer.execute_terminal_entity(inner_forward_node, A, A_data, para, env)  ## 执行该节点之内层的前向的节点实体
                elif (
                        inner_forward_node.attribute.node_type == {"process node", "container node"} and inner_forward_node.attribute.content_type == {"algorithm content"}
                ) or (
                        inner_forward_node.attribute.node_type == {"process node", "container node"} and inner_forward_node.attribute.content_type == {"model content"}
                ):
                    inner_forward_node, A, A_data, para, env = Executer.execute_branch_entity(inner_forward_node, A, A_data, para, env)  ## 执行该节点之内层的前向的节点实体
                else:
                    ## 如果是开始节点
                    if inner_forward_node.attribute.entity_name == "node_START":
                        inner_forward_node.attribute.other['process_state'] = "has processed"
                        pass  # if

                    ## 如果是结束节点
                    if inner_forward_node.attribute.entity_name == "node_END":
                        inner_forward_node.attribute.other['process_state'] = "has processed"
                        pass  # if

                    pass  # if

                ## 处理流向
                conditions = []  # 条件结果列表
                if inner_forward_node.process.__len__() != 0:
                    for arrow in inner_forward_node.process:  ## 判断每个条件
                        condition = eval(arrow['condition'])  # 计算条件值
                        logging.debug("        条件【%s】是 %s", arrow['condition'], condition)
                        conditions.append(condition)
                        pass  # for
                    inner_forward_node = inner_forward_node.process[conditions.index(True)]['direction']  # 判断在当前条件下，符合条件的前向的节点
                    logging.debug("        方向是【节点：%s，算法：%s %s】", inner_forward_node.attribute.entity_name, inner_forward_node.content.attribute.entity_name, inner_forward_node.content.attribute.text_name)
                    pass  # if
                else:  # 结束节点
                    pass  # if
               
                pass  # while

            node.attribute.other['process_state'] == "has processed"  # 标记节点之处理状态为处理完成

        ## 如果实体之节点之类型是 {"process node"}，且内容之类型是 {"process content"}（NOTE：开始节点`node_START`、结束节点`node_END`），则处理：
        if node.attribute.node_type == {"process node"} and node.attribute.content_type == {"process content"}:

            if node.attribute.entity_name == "node_START":  ## 如果是开始节点
                node.attribute.other['process_state'] = "has processed"
                pass  # if
            elif node.attribute.entity_name == "node_END":  ## 如果是结束节点
                node.attribute.other['process_state'] = "has processed"
                pass  # if

            pass  # if

        return node, A, A_data, para, env
        pass  # method

    ## TODO 后续需要用到类似`content_BI1111.content`的时候再继续
    @classmethod
    def process_entity(cls, entity: Entity):  # TODO处理过程类型的实体
        """
        Args:
            entity ():
        """
        pass  # method

    @classmethod
    def process_condition(cls, entity: Entity):  # TODO 处理过程类型的实体之条件
        conditions = []  # 条件列表
        for (i, out_flow_entity) in enumerate(entity.process):  ## 判断每个条件
            condition = eval(out_flow_entity['condition']) if out_flow_entity[
                                                                  'condition'] is not None else None  # NOTE 其实判断None这个条件是多余的，因为
            logging.debug("        条件【%s】是 %s", out_flow_entity['condition'], condition)
            conditions.append(condition)
        out_flow_entity = entity.process[conditions.index(True)]['flow']

        return conditions, out_flow_entity
        pass  # method

    pass  # class

```



## 执行实体过程相关的代码



### executer.py



```python
"""
执行机
"""

from .import logging
from .core.define.define_agentDataCollection import AgentDataCollection
from .core.define.define_agents import Agent
from .core.define.define_entity import Entity
from .core.define.define_type import *

pass  # end import


class Executer:
    """
    执行机
    """

    @classmethod
    def execute_branch_entity(cls, node: Entity, agent: Agent, agentData: AgentDataCollection, para: dict, env: dict):
        """
        执行分支实体。
        输入参数将被直接修改。

        Args:
            node (Entity): 节点实体（NOTE：本函数中，特指节点实体而非算法实体。算法实体表示`entity`。）
            agent (Agent): Agent群变量
            agentData (AgentDataCollection): Agent群变量之数据
            para (dict): 参数变量
            env (dict): 环境变量

        Returns: modelEntity, A, para, env, agentData

        """
        entity = node.content  # 获取节点实体对应的算法实体

        # if node.attribute.node_type == {"process node", "container node"}:
        logging.debug("- 入过程：%s %s", entity.attribute.text_name, entity.attribute.entity_name)

        node, agent, agentData, para, env = entity.execute(node, agent, agentData, para, env)

        # if node.attribute.node_type == {"process node", "container node"}:
        logging.debug("- 出过程：%s %s", entity.attribute.text_name, entity.attribute.entity_name)

        return node, agent, agentData, para, env
        pass  # method

    @classmethod
    def execute_terminal_entity(cls, A: Agent, b: StateType, ib: StateType, para: dict, env: dict, node: Entity):
        """
        执行终端实体。
        输入参数将被直接修改。

        Args:
            A (Agent): Agent群变量
            b (StateType): 示性向量
            ib (StateType): 邻接矩阵示性矩阵
            para (dict): 参数变量
            env (dict): 环境变量
            node (Entity): 节点实体（NOTE：本函数中，特指节点实体而非算法实体。算法实体表示`entity`。）

        Returns: agent

        """
        entity = node.content  # 获取节点实体对应的算法实体

        logging.debug("- - 开始阶段：%s %s", entity.attribute.text_name, entity.attribute.entity_name)

        env['round'] += 1  # 计次回合数

        A.BB, A.BI = entity.execute(A.BB, A.BI, b, ib, para, env)

        logging.debug("- - 结束阶段：%s %s", entity.attribute.text_name, entity.attribute.entity_name)

        return A
        pass  # method

    # @classmethod
    # def execute_special_entity(cls, node:Entity): #HACK 暂时不需要使用
    #     """
    #     执行特殊实体。特殊实体指：开始节点实体、结束节点实体。
    #
    #     Args:
    #         node (Entity): 节点实体（NOTE：本函数中，特指节点实体而非算法实体。算法实体表示`entity`。）
    #
    #     Returns: node
    #
    #     """
    #
    #     entity = node.content  # 获取节点实体对应的算法实体
    #
    #     # if node.attribute.node_type == {"process node", "container node"}:
    #     logging.debug("- 入过程：%s %s", entity.attribute.text_name, entity.attribute.entity_name)
    #
    #     node, agent, agentData, para, env = entity.execute(node)
    #
    #     # if node.attribute.node_type == {"process node", "container node"}:
    #     logging.debug("- 出过程：%s %s", entity.attribute.text_name, entity.attribute.entity_name)
    #
    #     pass  # method

    pass  # class

```




## 附录代码

### 从包批量导入模块与方法`import_modules_from_package.py`


```python
@classmethod  
def import_modules_from_package(cls, folderpath: str, pattern: str):  
"""  
从包批量导入模块与方法  
  
Args:  
folderpath: 包所在路径  
env: 环境变量  
  
Returns:  
env += env['list_entityData']  
"""  
  
# folderpath = cls._translate_package_form_path_to_folder_form_path(package_form_path) # NOTE 仅当如果用到以模块形式的包之路径的时候启用。  
module_form_path_package = cls._translate_folder_form_path_to_package_form_path(folderpath[0])  
  
## 遍历以导入内容函数  
idx_file = 0  
list_files = [] # 文件列表  
list_contents = {} # 内容列表  
  
for module_finder_01, name_01, is_pkg in pkgutil.walk_packages([folderpath[0].__str__()]):  
if is_pkg: # 如果路径下面还有一级子文件夹  
for module_finder_02, name_02, _ in pkgutil.iter_modules([Path(module_finder_01.path).joinpath(name_01).__str__()]):  
list_files.append(importlib.import_module("." + name_02, module_form_path_package + "." + Path(module_finder_02.path).name))  
if re.search(pattern, Path(list_files[idx_file].__str__()).name) is not None:  
for content in dir(list_files[idx_file]):  
if re.search(pattern, content.__str__()) is not None:  
list_contents.update({name_02: list_files[idx_file].__dict__.get(content)})  
idx_file += 1  
else: # 如果路径下面没有子文件夹  
# for module_finder, name_01, _ in pkgutil.iter_modules([folderpath[0].__str__()]):  
list_files.append(importlib.import_module("." + name_01, module_form_path_package))  
for content in dir(list_files[idx_file]):  
if not content.startswith("__"):  
list_contents.update({list_files[idx_file].__dict__.get(content)['attribute']['entity_name']: list_files[idx_file].__dict__.get(content)})  
idx_file += 1  
  
return list_contents
```
