
# 实体数据结构和过程机制


tags: #日期/2023-01-31 #类型/想法 #类型/笔记 #内容/过程机制 



> [!info]
> 节选自现有的一个项目工程，部分有删减。


> [!todo] 
> - [ ] 后续要加入采用非递归的方法实现的例子；
> - [ ] 后续加入采用编译器实现的例子；
> - [ ] 后续重命名一些组件名称；


# 过程机制


## 编译机制


![[串行编译实体过程.svg]]



## 处理和执行实体过程

![[处理和执行实体过程.svg]]



![[模型实体过程样例.svg]]

## 实体结构图与运作过程

![[实体结构图与运作过程.svg]]


## 实体结构

### 实体结构（新版）

![[实体结构.svg]]






### 实体结构（旧版）


![[实体结构（旧版）.svg]]


## 实体过程结构示例图


### 实体过程结构示例图（新版）

![[实体过程结构示例图（新版）.svg]]



### 实体过程结构示例图（旧版）

![[实体过程结构示例图（旧版）.svg]]

## 实体数据结构

### 实体数据结构（新版）

![[实体数据结构.svg]]


### 实体数据结构（旧版）

![[实体数据结构（旧版）.svg]]






# 实体数据结构和过程流处理相关的代码



## 初始状态实体数据结构相关的代码：



### entityData_BI1111.py



```python
"""
实体数据之模型BI1111
"""
# import here

entityData_BI1111 = dict(
    attribute=dict(
        id=2000,
        entity_name="entity_BI1111",
        text_name="模型算法BI1111",
        node_type={"container node", "process node"},
        content_type={"model content"},
    ),
      container=dict({
        "node_START": "entity_START",
        "node_01": "entity_EBisv",
        "node_02": "entity_IBisv",
        "node_03": "entity_EBilq",
        "node_04": "entity_IBilq",
        "node_END": "entity_END",
    }),
    condition=dict({
        # "node_START_condition_01": "True",
        "node_01_condition_01": "(A.BB.isv != A_data.BB[env['round']-1]['dataBB'].isv).any()",
        "node_01_condition_02": "(A.BB.isv == A_data.BB[env['round']-1]['dataBB'].isv).all()",
        "node_02_condition_01": "(A.BB.isv != A_data.BB[env['round']-1]['dataBB'].isv).any()",
        "node_02_condition_02": "(A.BB.isv == A_data.BB[env['round']-1]['dataBB'].isv).all()",
        "node_03_condition_01": "(A.BB.ilq != A_data.BB[env['round']-1]['dataBB'].ilq).any()",
        "node_03_condition_02": "(A.BB.ilq == A_data.BB[env['round']-1]['dataBB'].ilq).all()",
        "node_04_condition_01": "(A.BB.ilq != A_data.BB[env['round']-1]['dataBB'].ilq).any()",
        "node_04_condition_02": "(A.BB.ilq == A_data.BB[env['round']-1]['dataBB'].ilq).all()",
    }),

    execute="Processor.process",
    content=content_IB1111= \
    """
    define process entity_IB1111
    
    execute content node_START
    
    execute process node_01
    if node_01_condition_01 goto node_02
    if node_01_condition_02 goto node_03
    
    execute process node_02
    if node_02_condition_01 goto node_02
    if node_02_condition_02 goto node_03
    
    execute process node_03
    if node_03_condition_01 goto node_04
    if node_03_condition_02 goto node_END
    
    execute process node_04
    if node_04_condition_01 goto node_04
    if node_04_condition_02 goto node_END
    
    execute content node_END
    
    end define
    """
    node=list([
        dict(
            node=dict(
                name="node_START",
                content="entity_START",
                process=list([
                    dict(
                        arrow=dict(
                            condition="True",
                            direction="node_01",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_01",
                content="entity_EBisv",
                process=list([
                    dict(
                        arrow=dict(
                            condition="A.BB.isv.any() != A_data.BB[env['round']-1]['dataBB'].isv.any()",
                            direction="node_02",
                        ),
                    ),
                    dict(
                        arrow=dict(
                            condition="A.BB.isv.all() == A_data.BB[env['round']-1]['dataBB'].isv.all()",
                            direction="node_03",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_02",
                content="entity_IBisv",
                process=list([
                    dict(
                        arrow=dict(
                            condition="A.BB.isv.any() != A_data.BB[env['round']-1]['dataBB'].isv.any()",
                            direction="node_02",
                        ),
                    ),
                    dict(
                        arrow=dict(
                            condition="A.BB.isv.all() == A_data.BB[env['round']-1]['dataBB'].isv.all()",
                            direction="node_03",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_03",
                content="entity_EBilq",
                process=list([
                    dict(
                        arrow=dict(
                            condition="A.BB.ilq.any() != A_data.BB[env['round']-1]['dataBB'].ilq.any()",
                            direction="node_04",
                        ),
                    ),
                    dict(
                        arrow=dict(
                            condition="A.BB.ilq.all() == A_data.BB[env['round']-1]['dataBB'].ilq.all()",
                            direction="node_END",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_04",
                content="entity_IBilq",
                process=list([
                    dict(
                        arrow=dict(
                            condition="A.BB.ilq.any() != A_data.BB[env['round']-1]['dataBB'].ilq.any()",
                            direction="node_04",
                        ),
                    ),
                    dict(
                        arrow=dict(
                            condition="A.BB.ilq.all() == A_data.BB[env['round']-1]['dataBB'].ilq.all()",
                            direction="node_END",
                        ),
                    ),
                    # dict( #HACK 先暂时不考虑，因为这个过程还未完成。目前为了测试调度框架。
                    #     direction="entity_IBbrp",
                    #     condition=" TODO ",
                    # ),
                ]),
            ),
        ),
        # dict(#HACK 先暂时不考虑，因为这个过程还未完成。目前为了测试调度框架。
        #     node=dict(
        #         name="node_05",
        #         content="entity_IBbrp",
        #         process=list([
        #         ]),
        #     ),
        # ),
        dict(
            node=dict(
                name="node_END",
                content="entity_END",
                process=list([
                    dict(
                        arrow=None,
                    ),
                ]),
            ),
        ),
    ])
)

```





### entityData_START.py



```python
"""
开始实体
"""

entityData_START = dict(
    attribute=dict(
        id=0000,
        entity_name="entity_START",
        text_name="开始",
        node_type={"process node"},
        content_type={"process content"},
    ),
    container=None,
    condition=None,
    execute="Processor.process",
    content=None,
    node=None,
)

```



### entityData_END.py



```python
"""
结束实体
"""

entityData_START = dict(
    attribute=dict(
        id=9999,
        entity_name="entity_END",
        text_name="结束",
        node_type={"process node"},
        content_type={"process content"},
    ),
    container=None,
    condition=None,
    execute="Processor.process",
    content=None,
    node=None,
)
```



### entityData_IBisv.py

```python

# import here

entityData_IBisv = dict(
    attribute=dict(
        id=2020,
        entity_name="entity_IBisv",
        text_name="XXXXXXXXXX",
        node_type={"container node", "process node"},
        content_type={"algorithm content"},
    ),
      process="content_EBisv",
      container=dict({
        "node_START": "entity_START",
        "node_01": "entity_EBisvShock",
        "node_END": "entity_END",
    }),

    content=content_EBisv= \
    """
    define process entity_EBisv
    
    execute content node_START

    execute content node_01

    execute content node_END
    
    end define
    """
    execute="Processor.process",
    content=None,  # TODO等需要的时候再写
    node=list([
        dict(
            node=dict(
                name="node_START",
                content="entity_START",
                process=list([
                    dict(
                        arrow=dict(
                            condition="True",
                            direction="node_01",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_01",
                content="entity_IBisvc",
                process=list([
                    dict(
                        arrow=dict(
                            condition="True",
                            direction="node_02",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_02",
                content="entity_IBisvs",
                process=list([
                    dict(
                        arrow=dict(
                            condition="True",
                            direction="node_END",
                        ),
                    ),
                ]),
            ),
        ),
        dict(
            node=dict(
                name="node_END",
                content="entity_END",
                process=list([
                    dict(
                        arrow=None,
                    ),
                ]),
            ),
        ),
    ]),
)

```





### entityData_IBisvs.py

```python


# import here

pass  # end import

entityData_IBisvs = dict(
    attribute=dict(
        id=4020,
        entity_name="entity_IBisvs",
        text_name="XXXXXXXX",
        node_type={"content node"},
        content_type={"algorithm content"},
    ),
    execute="content_IBisvs",
    content=None,
    node=None,
)

```



### entityData_IBisvc.py



```python


# import here

pass  # end import

entityData_IBisvc = dict(
    attribute=dict(
        id=4030,
        entity_name="entity_IBisvc",
        text_name="XXXXXXXXXX",
        node_type={"content node"},
        content_type={"algorithm content"},
    ),
    execute="content_IBisvc",
    content=None,
    node=None,
)

```















## 构建实体过程相关的代码



### builder.py





构建机提供了两种构建方法：

- 基于过程组件、容器组件、条件组件（严格地说条件组件之各条件可以被放入容器组件中）与其他必要组件构建实体`build_entities_by_process_and_container_component`；
- 基于节点组件与其他必要组件构建实体`build_entities_by_node_component`；



```python
"""
构建机
"""

from . import Any, deepcopy, re
from .core.define.define_type import EnvironmentVariableType
from .core.define.define_environmentVariables import env
from .core.operations.entity_manager import EntityManager
from .core.operations.compiler import Compiler
from .core.operations.processor import Processor  # NOTE 动态导入，严禁删除
from .tools.tools import Tools

pass  # end import


class Builder:
    """构建机"""

    @classmethod
    def build_entities_by_process_and_container_component(cls, env: EnvironmentVariableType = env):
        """
        构建实体众，通过过程组件。

        Args:
            env(EnvironmentVariableType): 环境变量集

        Returns:
            algorithmEntities: 算法实体列表, algorithmContents: 算法内容列表

        """
        ## 导入相关模块（#NOTE 动态导入，严禁删除）
        ## 导入模型、过程、算法初始态实体之数据内容
        import .models.entities_data
        list_entityData = Tools.import_modules_from_package(env['folderpath_import_modules'], r"entityData_")

        ## 导入模型、过程、算法内容
        import .models.contents
        algorithmContents = Tools.import_modules_from_package(env['folderpath_import_modules'], r"content_")

        ## 根据算法实体数据列表之数据，生成相应的算法实体对象，然后组成算法实体列表
        for entityData in list_entityData.values():
            EntityManager.create_entity(entityData=entityData)  # 根据实体数据，创建每个实体
            pass  # for

        ## 补充算法实体之特征
        for algorithmEntity in EntityManager.algorithmEntities.values():
            if algorithmEntity.attribute.content_name is None:
                algorithmEntity.attribute.content_name = algorithmEntity.content  # 内容名称`content_name`
            pass  # for

        ## 补充模型算法实体之特征
        for modelAlgorithmEntity in EntityManager.modelAlgorithmEntities.values():
            modelAlgorithmEntity.attribute.other['process_state'] = "has not process"  # 设置节点之处理状态

        ## 生成算法实体之节点实体
        for algorithmEntity in EntityManager.algorithmEntities.values():
            nodeEntities = {}
            if algorithmEntity.container is not None:
                for node_name, node_value in algorithmEntity.container.items():
                    nodeEntity = EntityManager.create_entity()  # 构造一个空节点实体
                    nodeEntity.attribute.entity_name = node_name  # 设置节点实体之名称
                    nodeEntity.attribute.node_type = {"container node"}  # 设置节点实体之节点类型
                    nodeEntity.attribute.content_type = {"node content"}  # 设置节点实体之内容类型
                    if nodeEntity.content is None:
                        nodeEntity.content = node_value  # 设置节点实体之内容组件。此时，其内容为算法实体之字符串数据，需要进一步装配。#BUG 是否应该放在content而不是execute？
                        pass  # if
                    nodeEntities[node_name] = nodeEntity  # 生成节点实体字典列表
                    pass  # for
                algorithmEntity.container = nodeEntities  # 构建节点：将节点组件之值替换成节点实体字典列表之值
                pass  # if
            pass  # for

        ## 装配算法实体之节点实体之内容组件
        for algorithmEntity in EntityManager.algorithmEntities.values():
            if (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"model content", "algorithm content"}
            ):
                for nodeEntity in algorithmEntity.container.values():
                    # if not (nodeEntity.content is None or nodeEntity.content is 'entity_START' or nodeEntity.content is 'entity_END'):
                    if nodeEntity.content is not None:
                        nodeEntity.content = EntityManager.algorithmEntities[nodeEntity.content]
                        pass  # if
                    pass  # for
                continue
                pass  # if
            pass  # for

        ## 生成算法实体之条件实体
        for algorithmEntity in EntityManager.algorithmEntities.values():
            conditionEntities = {}
            if algorithmEntity.condition is not None:
                for condition_name, condition_value in algorithmEntity.condition.items():
                    conditionEntity = EntityManager.create_entity()  # 构造一个空条件实体
                    conditionEntity.attribute.entity_name = condition_name  # 设置条件实体之名称
                    nodeEntity.attribute.node_type = {"condition node"}  # 设置条件实体之节点类型
                    if conditionEntity.content is not None:
                        conditionEntity.content = condition_value  # 设置条件实体之内容组件。此时其内容为表达式字符串数据，需要进一步解析。 #BUG 是否应该放在content而不是execute？
                        pass  # if
                    conditionEntities[condition_name] = conditionEntity  # 生成条件实体字典列表
                    pass  # for
                algorithmEntity.condition = conditionEntities  # 构建条件：将条件组件之值替换成条件实体字典列表之值
                pass  # if
            pass  # for

        ## 装配算法实体之执行器：将算法实体之执行器之值链接至对应的算法内容功能函数
        for algorithmEntity in EntityManager.algorithmEntities.values():
            if (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"model content", "algorithm content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"process node"} and
                    algorithmEntity.attribute.content_type == {"process content"}
            ):
                if algorithmEntity.execute is not None:
                    algorithmEntity.execute = eval(algorithmEntity.execute)  # 设置执行器之值是处理机 #BUG 是否有必要继续用处理机处理？
                    pass  # if
                pass  # if
            if (
                    algorithmEntity.attribute.node_type == {"content node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ):
                algorithmEntity.execute = algorithmContents[algorithmEntity.execute]  # 设置执行器之值是具体的算法内容
                pass  # if
            pass  # for

        ## 装配算法实体之过程组件
        for algorithmEntity in EntityManager.algorithmEntities.values():
            if algorithmEntity.process is not None:
                algorithmEntity.process = algorithmContents[algorithmEntity.process]
                pass  # if
            pass  # for

        ## 生成模型节点实体（模型实体）用于存放对应的模型算法实体
        for modelAlgorithmEntity in EntityManager.modelAlgorithmEntities.values():
            modelEntity_name = modelAlgorithmEntity.attribute.entity_name
            modelEntity = EntityManager.create_entity(entity_name='model_' + modelEntity_name, node_type={"container node"}, content_type={"model content", "node content"})  # 构造一个空实体
            modelEntity.content = modelAlgorithmEntity  # 设置模型节点实体之内容组件为模型算法实体

        ## 装配模型算法实体之过程组件
        ## 编译模型算法实体。
        ## 编译过程会自动编译主程序相关的各子程序过程。最终生成一个可执行的主程序过程，然后装配到模型算法实体之过程组件。
        for modelEntity in EntityManager.modelEntities.values():
            compile_process = Compiler.compile(modelEntity)
            modelAlgorithmEntity = modelEntity.content
            modelAlgorithmEntity.process = compile_process
            pass  # for

        pass  # def

    @classmethod
    def build_entities_by_node_component(cls, env: EnvironmentVariableType = env):  # FIXME 已经过时
        """
        构建实体众，通过节点组件。#HACK暂时不用。还没有适配新版。以后可能会改造或者删除

        Args:
            env(EnvironmentVariableType): 环境变量集

        Returns:
            algorithmEntities: 算法实体列表, algorithmContents: 算法内容列表

        """

        ## 导入相关模块（#NOTE 动态导入，严禁删除）
        ## 导入模型、过程、算法初始态实体之数据内容
        import .models.entities_data
        env['list_entityData'] = Tools.import_modules_from_package(env['folderpath_import_modules'], r"entityData_")
        ## 导入模型、过程、算法内容
        import .models.contents
        env['list_algorithm_contents'] = Tools.import_modules_from_package(env['folderpath_import_modules'], r"content_")

        ## 生成算法内容列表
        algorithmContents = env['list_algorithm_contents']

        ## 根据算法实体数据列表之数据，生成相应的算法实体对象，然后组成算法实体列表
        algorithmEntities = {}
        for entityData_name, entityData in env['list_entityData'].items():
            algorithmEntity = EntityManager.create_entity(entityData=entityData)  # 构造每个实体
            algorithmEntities[entityData_name] = deepcopy(algorithmEntity)
            pass  # for

        ## 补充算法实体之特征
        for algorithmEntity in algorithmEntities.values():
            if algorithmEntity.attribute.content_name is None:
                algorithmEntity.attribute.content_name = algorithmEntity.content  # 内容名称`content_name`
            pass  # for

        ## 生成节点实体列表
        for algorithmEntity in algorithmEntities.values():
            nodeEntities = {}
            if algorithmEntity.node is not None:
                for node in algorithmEntity.node:
                    if node is not None:
                        ## 构建一个节点实体
                        nodeEntity = deepcopy(algorithmEntities[node['node']['content']])  # 先直接复制以继承该节点实体对应的算法实体之值，然后再改造
                        nodeEntity.attribute.id = None
                        nodeEntity.attribute.entity_name = node['node']['name']  # 设置节点之名称
                        nodeEntity.attribute.content_name = None
                        nodeEntity.attribute.text_name = None
                        nodeEntity.attribute.other['process_state'] = "has not process"  # 设置节点之处理状态
                        nodeEntity.process = node['node']['process']
                        nodeEntity.execute = None
                        nodeEntity.node = None
                        nodeEntity.content = node['node']['content']  # 设置节点之内容
                        ## 生成节点实体列表
                        nodeEntities[node['node']['name']] = nodeEntity
                        pass  # if
                    pass  # for
                ## 构建节点组件：将节点组件之值替换成节点实体字典列表之值
                algorithmEntity.node = nodeEntities
                del nodeEntities

                ## 构建过程：将过程之值改成箭头实体列表之值
                for node in algorithmEntity.node.values():
                    arrowEntities = []
                    if node.process is not None:
                        for idx_arrow, arrow in enumerate(node.process):
                            if arrow['arrow'] is not None:
                                arrowEntities.append(arrow['arrow'])
                        algorithmEntity.node[node.attribute.entity_name].process = arrowEntities
                        del arrowEntities
                    pass  # for

            pass  # for

        ## 装配箭头实体：将过程之箭头实体之方向之值链接至节点组件之对应的节点实体
        for algorithmEntity in algorithmEntities.values():
            if algorithmEntity.node is not None:
                for node in algorithmEntity.node.values():
                    if node.process is not None:
                        for arrow_value in node.process:
                            arrow_value['direction'] = algorithmEntity.node[arrow_value['direction']]
            pass  # for

        ## 装配节点实体：将节点组件之节点实体之内容之值链接至对应的算法实体
        for algorithmEntity in algorithmEntities.values():
            if algorithmEntity.node is not None:
                for node in algorithmEntity.node.values():
                    node.content = algorithmEntities[node.content]
            pass  # for

        ## 装配算法实体之内容：将算法实体之内容之值链接至对应的算法内容功能函数
        for algorithmEntity in algorithmEntities.values():
            if (
                    algorithmEntity.attribute.node_type == {"process node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"process node"} and
                    algorithmEntity.attribute.content_type == {"process content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"model content", "algorithm content"}
            ):
                if algorithmEntity.content is not None:
                    algorithmEntity.content = algorithmContents[algorithmEntity.content]
                    pass  # if
                pass  # if
            pass  # for

        ## 装配算法实体之执行器：将算法实体之执行器之值链接至对应的算法内容功能函数
        for algorithmEntity in algorithmEntities.values():
            if (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"container node", "process node"} and
                    algorithmEntity.attribute.content_type == {"model content", "algorithm content"}
            ) or (
                    algorithmEntity.attribute.node_type == {"process node"} and
                    algorithmEntity.attribute.content_type == {"process content"}
            ):
                if algorithmEntity.execute is not None:
                    algorithmEntity.execute = eval(algorithmEntity.execute)  # 设置执行器之值是处理机
                    pass  # if
                pass  # if
            if (
                    algorithmEntity.attribute.node_type == {"content node"} and
                    algorithmEntity.attribute.content_type == {"algorithm content"}
            ):
                algorithmEntity.execute = algorithmContents[algorithmEntity.execute]  # 设置执行器之值是具体的算法内容
                pass  # if
            pass  # for

        ## 生成模型节点实体（暨根节点实体，简称模型实体）字典列表
        modelEntities = {}
        for algorithmEntity in algorithmEntities.values():
            if algorithmEntity.attribute.content_type == {"model content", "algorithm content"}:
                pattern = r'_'
                ## 构建一个节点实体
                modelEntity = deepcopy(algorithmEntity)  # 先直接复制以继承该节点实体对应的算法实体之值，然后再改造
                modelEntity.attribute.id = None
                modelEntity.attribute.entity_name = "entity_" + re.split(pattern, algorithmEntity.attribute.entity_name)[1]  # 设置节点之名称
                modelEntity.attribute.content_name = None
                modelEntity.attribute.text_name = None
                modelEntity.attribute.other['process_state'] = "has not process"  # 设置节点之处理状态
                modelEntity.process = None
                modelEntity.execute = None
                modelEntity.node = None
                modelEntity.content = algorithmEntity  # 设置节点之内容
                modelEntities[algorithmEntity.attribute.entity_name] = modelEntity
                pass  # if
            pass  # for

        return modelEntities
        pass  # method

    pass  # class



```







## 编译实体之过程相关的代码



```python
"""
编译机。用于编译过程组件之内容。

#HACK 没有做覆盖性的单元测试。目前只要求能够在主程序中正确运行就好。
"""

from . import logging

from .core.define.define_entity import Entity
from .core.operations.tree_structure import Tree
from .core.operations.stack_structure import Stack


class Compiler:
    """
    编译机

    编译后的指令列表有几种形式的元组：

    - `node XXX`。3元组。元素1是指令行号；元素2是指令`node`；元素3是指令内容是算法实体之节点实体`id`；

    - `execute XXX`。3元组。元素1是指令行号；元素2是指令`execute`；元素3是指令内容是算法实体之内容变量；

    - `if XXX goto XXX`。5元组。元素1是指令行号；元素2是指令`if`；元素3是指令内容是算法实体之条件实体，呈现以字符串形式的内容；元素4是指令`goto`；元素5是指令内容是算法实体之节点实体`id`；

    """

    def __init__(self):
        self.instructions = []

    # @classmethod
    def execute(self, node):
        self.instructions.append((self.line_number, 'execute', node))

    # @classmethod
    def discriminate(self, condition, conditions):
        self.instructions.append(('discriminate', condition, conditions))

    # @classmethod
    def goto(self, position):
        self.instructions.append(('goto', position))

    @classmethod
    def compile(cls, model_nodeEntity: Entity):
        """
        编译。

        编译过程分为三步：

        1. 构建编译树；

                遍历所有节点实体过程，生成编译树用于生成编译序列。

        2. 生成编译序列；

            该功能是生成一个编译序列，以记录编制整个程序代码段完整的编译路径。

        3. 编译；

            该功能是根据编译序列，执行编译过程，生成编译指令列表。

        Args:
            model_nodeEntity (Entity): 待编译的模型实体（模型节点实体）。

        Returns:

        """

        ## 预编译阶段

        ## 生成一棵编译树。
        logging.debug(f"\n\n\n开始生成编译树。\n")
        compile_tree = Tree()  # 创建一棵编译树
        build_tree_stack = Stack()  # 【生成树栈】，栈之元素是编译树节点实体之id。
        compile_tree.root_node.content = model_nodeEntity  # 设置编译树之根节点之内容
        build_tree_stack.push(compile_tree.root_node)  # 将根节点压入栈
        ## 生成编译树
        while not build_tree_stack.is_empty():  # 当栈不为空时
            compile_tree_node = build_tree_stack.pop()  # 弹出节点，进行处理。
            logging.debug(f"栈弹出节点{compile_tree_node.attribute.entity_name}，变成{build_tree_stack.print_stack(mode='return')}。")
            compile_nodeEntity = compile_tree_node.content  # 获取编译树节点之对应的节点实体
            compile_algorithmEntity = compile_nodeEntity.content  # 获取编译树节点之对应的节点实体
            if compile_algorithmEntity.process is not None:
                compile_tree_node.attribute.other = {'is_terminal': False}
            else:
                compile_tree_node.attribute.other = {'is_terminal': True}
                pass  # if
            code_process_content = compile_algorithmEntity.process  # 获取算法实体之过程，其内容是代码段
            code_lines = code_process_content.split('\n')  # 将代码分割成很多行
            compile_tree_node.attribute.other['start_line_number'] = 1  # 设置编译树节点之起始行号
            compile_tree_node.attribute.other['end_line_number'] = len(code_lines)  # 设置编译树节点之结束行号
            sub_node_list = []  # 当前节点之子节点列表
            ## 逐行扫描代码段，生成子节点
            for line_number, line in enumerate(code_lines):
                ## 判断是否是有效指令行
                if line.strip() == '' or line.strip().startswith('#'):  # 忽略空行和注释行
                    continue
                tokens = line.strip().split(' ')  # 分割代码行为关键字和参数
                ## 如果指令是`execute process xxx`，则说明需要进入该子过程编译。添加编译树子节点实体到编译树中。
                if tokens[0] == 'execute' and (tokens[1] == 'process'):
                    sub_process_name = tokens[2]  # 获取子过程名称
                    compile_tree_sub_node = compile_tree.create_and_add_node(entity_name=sub_process_name, parent_item=compile_tree_node)  # 创建编译树子节点实体
                    compile_tree_sub_node.content = compile_algorithmEntity.container[sub_process_name]  # 设置编译树子节点之内容为该算法实体之子节点实体
                    sub_node_list.append(compile_tree_sub_node)  # 暂存编译树子节点实体。等待遍历完当前节点实体的所有子节点实体后，再压入栈。
                    pass  # if
                ## 如果指令是`end define`，则标记位置，表示该过程编译结束
                if tokens[0] == 'end' and tokens[1] == 'define':
                    break
                    pass  # if
                pass  # for
            if len(sub_node_list) == 0:  # 如果当前算法节点没有子节点，则标记该编译树节点为终端节点，否则标记为非终端节点
                compile_tree_node.attribute.other['is_terminal'] = True
                continue
            else:
                compile_tree_node.attribute.other['is_terminal'] = False
                sub_node_list.reverse()  # 将编译树子节点实体倒序压入栈。这样做的目的是为了保证栈中的节点顺序和编译序列中的节点顺序一致。
                build_tree_stack.push(sub_node_list)
                logging.debug(f"栈压入节点{'[' + ', '.join([node.attribute.entity_name for node in sub_node_list]) + ']'}，变成{build_tree_stack.print_stack(mode='return')}。")
                pass  # if
            pass  # while
        ## 打印编译树
        logging.debug(f"编译树：")
        compile_tree.print_tree()

        ## 遍历编译树生成编译序列。
        ## NOTE：从树的遍历算法上看，本质上是中序遍历。从应用上来比喻，相当于实现从头到尾的跳步阅读行为。
        logging.debug(f"\n\n\n开始遍历编译树生成编译序列：\n")
        compile_order_list = []  # 编译序列列表。每个元素是一个5元组。元素1是编译树节点实体，元素2是待编译的节点实体，元素3是待编译的算法实体，元素4是待编译的节点之过程之代码段之开始编译的行号，元素5是待编译的节点之过程之代码段之停止编译的行号。
        precompile_stack = Stack()  # 预编译栈。，栈之元素是待编译的节点之id。
        precompile_stack.push(compile_tree.root_node)  # 将根节点压入栈
        ## 遍历编译树，生成编译序列
        while not precompile_stack.is_empty():  # 当栈不为空时
            compile_tree_node = precompile_stack.pop()  # 弹出节点，进行处理。
            logging.debug(f"栈弹出节点{compile_tree_node.attribute.entity_name}，变成{precompile_stack.print_stack(mode='return')}。")
            if (compile_tree_node.attribute.other['is_terminal'] is False and compile_tree_node.attribute.other['start_line_number'] == 1):  # 如果该节点是非终端节点，且还没有预编译过，则将该节点再压入编译序列
                compile_tree_node_children = compile_tree.get_children(compile_tree_node)  # 获取该编译树节点之所有子节点
                ## 倒序、遍历该编译树节点之所有子节点，然后间隔插入父节点，再压入栈。
                if len(compile_tree_node_children) is not 0:
                    compile_tree_node_children.reverse()
                    for compile_tree_node_child in compile_tree_node_children:
                        precompile_stack.push(compile_tree_node)  # 将该编译树节点压入栈
                        logging.debug(f"栈压入节点{compile_tree_node.attribute.entity_name}，变成{precompile_stack.print_stack(mode='return')}。")
                        precompile_stack.push(compile_tree_node_child)  # 将子节点压入栈
                        logging.debug(f"栈压入节点{compile_tree_node_child.attribute.entity_name}，变成{precompile_stack.print_stack(mode='return')}。")
                        pass  # for
                    pass  # if
                pass  # if

            compile_nodeEntity = compile_tree_node.content  # 获取编译树节点之对应的节点实体
            compile_algorithmEntity = compile_nodeEntity.content  # 获取编译树节点之对应的节点实体
            logging.debug(f'编译树节点{compile_tree_node.attribute.entity_name}，对应的算法实体之节点实体{compile_nodeEntity.attribute.entity_name}，对应的算法实体{compile_algorithmEntity.attribute.entity_name}')
            code_process_content = compile_algorithmEntity.process  # 获取算法实体之过程，其内容是代码段
            code_lines = code_process_content.split('\n')  # 将代码分割成很多行
            ## 逐行扫描代码段，生成编译序列
            line_number = compile_tree_node.attribute.other['start_line_number']  # 记录当前行号
            for line in code_lines[compile_tree_node.attribute.other['start_line_number']:]:
                ## 判断是否是有效指令行
                if line.strip() == '' or line.strip().startswith('#'):  # 忽略空行和注释行
                    line_number += 1  # 继续扫描下一行
                    continue
                    pass  # if
                logging.debug(f"当前行号：{line_number}，当前行内容：{line}。")
                tokens = line.strip().split(' ')  # 分割代码行为关键字和参数
                ## 如果指令是`execute process xxx`，则说明需要进入该子过程编译。添加编译树子节点实体到编译树中。
                if tokens[0] == 'execute' and (tokens[1] == 'process'):
                    compile_tree_node.attribute.other['end_line_number'] = line_number  # 标记需要编译的当前算法实体之过程代码段之结束行号到当前编译树节点实体之特征。
                    compile_order_list.append((compile_tree_node, compile_nodeEntity, compile_algorithmEntity, compile_tree_node.attribute.other['start_line_number'], compile_tree_node.attribute.other['end_line_number']))  # 添加当前编译节点、编译起止行号、特征之是否终端节点到编译序列中
                    compile_tree_node.attribute.other['start_line_number'] = line_number + 1  # 更新当前编译节点之过程代码段之初始位置
                    break  # 停止扫描当前编译节点之过程，转而扫描子节点。
                    pass  # if
                ## 如果是指令`define process`，则说明是编译该过程的起点
                if tokens[0] == 'define' and tokens[1] == 'process':
                    ## 标记当前编译节点之过程代码段之初始位置
                    compile_tree_node.attribute.other['start_line_number'] = line_number  # 标记当前编译节点之过程代码段之初始位置
                    line_number += 1  # 继续扫描下一行
                    continue
                    pass  # if
                ## 如果指令是`end define`，则标记位置，表示该过程编译结束
                if tokens[0] == 'end' and tokens[1] == 'define':
                    compile_tree_node.attribute.other['end_line_number'] = line_number  # 标记需要编译的当前算法实体之过程代码段之结束行号到当前编译树节点实体之特征。
                    compile_order_list.append((compile_tree_node, compile_nodeEntity, compile_algorithmEntity, compile_tree_node.attribute.other['start_line_number'], compile_tree_node.attribute.other['end_line_number']))  # 添加当前编译节点、编译起止行号到编译序列中。
                    break  # 停止扫描当前编译节点之过程，转而扫描父节点。
                ## 如果是其他指令
                else:
                    line_number += 1  # 继续扫描下一行
                    pass  # if
                pass  # for

            pass  # while
        ## 打印编译序列
        logging.debug(f"\n\n编译序列：\n")
        for i in range(len(compile_order_list)):
            logging.debug(f"树节点：{compile_order_list[i][0].attribute.entity_name}、节点：{compile_order_list[i][1].attribute.entity_name}、算法：{compile_order_list[i][2].attribute.entity_name}、起止行({str(compile_order_list[i][3])}, {str(compile_order_list[i][4])})")

        ## 编译阶段

        ## 编译。遍历编译序列依次编译每一段代码段。最后拼接起来，形成指令列表。
        logging.debug("\n\n\n开始编译：\n")
        instructions = []  # 编译后的指令列表。
        instructions_line_number = 1  # 指令行号
        for compile_item in compile_order_list:
            compile_tree_node, compile_nodeEntity, compile_algorithmEntity, start_line_number, end_line_number = compile_item[0], compile_item[1], compile_item[2], compile_item[3], compile_item[4]  # 获取编译节点实体、编译起止行号
            code_process_content = compile_algorithmEntity.process  # 获取算法实体之过程，其内容是代码段
            code_lines = code_process_content.split('\n')  # 将代码分割成很多行
            ## 逐行扫描代码段，生成编译序列
            for line in code_lines[start_line_number:end_line_number + 1]:
                ## 判断是否是有效指令行
                if line.strip() == '' or line.strip().startswith('#'):  # 忽略空行和注释行
                    continue
                    pass  # if
                tokens = line.strip().split(' ')  # 分割代码行为关键字和参数
                if tokens[0] == 'execute' and tokens[1] == 'content':  # 如果指令是`execute content`，则需要编译算法内容
                    instructions.append((instructions_line_number, 'node', compile_algorithmEntity.container[tokens[2]]))  # 生成指令`node <nodeEntity之id>`
                    logging.debug(f"{instructions[instructions_line_number - 1][0]}\t{instructions[instructions_line_number - 1][1]}\t\t{compile_algorithmEntity.container[tokens[2]].attribute.entity_name} {compile_algorithmEntity.container[tokens[2]].attribute.id}")
                    instructions_line_number += 1  # 下一指令行号
                    instructions.append((instructions_line_number, tokens[0], compile_algorithmEntity.container[tokens[2]]))  # 生成指令`execute <nodeEntity之algorithmContent>`。但是该指令之内容是文本形式的算法内容，需要在执行过程时再解析。
                    logging.debug(f"{instructions[instructions_line_number - 1][0]}\t{instructions[instructions_line_number - 1][1]}\t\t{compile_algorithmEntity.container[tokens[2]].attribute.entity_name} {compile_algorithmEntity.container[tokens[2]].attribute.id}")
                    instructions_line_number += 1  # 下一指令行号
                    continue
                    pass  # if
                ## 如果是连续的指令`if XXX goto XXX`，则编译判别条件
                if tokens[0] == 'if' and tokens[2] == 'goto':
                    instructions.append((instructions_line_number, tokens[0], compile_algorithmEntity.condition[tokens[1]], tokens[2], compile_algorithmEntity.container[tokens[3]].attribute.id))  # 生成指令。但是该指令之内容是文本形式的判别条件，需要在执行过程时再解析。
                    logging.debug(f"{instructions[instructions_line_number - 1][0]}\t{instructions[instructions_line_number - 1][1]}\t\t{tokens[1]}\t\t{instructions[instructions_line_number - 1][3]}\t\t{compile_nodeEntity.attribute.entity_name} {compile_nodeEntity.attribute.id}")
                    instructions_line_number += 1  # 下一指令行号
                    continue
                    pass  # if
                ## 如果是根节点之指令`define process xxx`，则编译成`start process xxx`
                if tokens[0] == 'define' and tokens[1] == 'process':
                    instructions.append((instructions_line_number, 'node', compile_nodeEntity.attribute.id))
                    logging.debug(f"{instructions[instructions_line_number - 1][0]}\t{instructions[instructions_line_number - 1][1]}\t\t{compile_nodeEntity.attribute.entity_name} {compile_nodeEntity.attribute.id}")
                    instructions_line_number += 1  # 下一指令行号
                    continue
                    pass  # if
                # ## 如果是根节点之指令`end define xxx`，则编译成`end process xxx`
                # if tokens[0] == 'end' and tokens[1] == 'define':
                #     instructions.append((instructions_line_number, 'end process', compile_nodeEntity.attribute.id))
                #     logging.debug(f"{instructions[instructions_line_number - 1][0]}\t{instructions[instructions_line_number - 1][1]}\t\t{compile_nodeEntity.attribute.entity_name} {compile_nodeEntity.attribute.id}")
                #     instructions_line_number += 1  # 下一指令行号
                #     continue
                #     pass  # if
                ## TODO 旧版本，后续考虑是否删除
                # if tokens[0] == 'execute' and tokens[1] == 'content':  # 如果指令是`execute content`，则需要编译算法内容
                #     instructions.append((instructions_line_number, 'node', compile_algorithmEntity.container[tokens[2]]))  # 生成指令`node <nodeEntity之id>`
                #     logging.debug(f"{instructions[instructions_line_number - 1][0]}\t{instructions[instructions_line_number - 1][1]}\t\t{compile_algorithmEntity.container[tokens[2]].attribute.entity_name} {compile_algorithmEntity.container[tokens[2]].attribute.id}")
                #     instructions_line_number += 1  # 下一指令行号
                #     instructions.append((instructions_line_number, tokens[0], compile_algorithmEntity.container[tokens[2]]))  # 生成指令`execute <nodeEntity之algorithmContent>`。但是该指令之内容是文本形式的算法内容，需要在执行过程时再解析。
                #     logging.debug(f"{instructions[instructions_line_number - 1][0]}\t{instructions[instructions_line_number - 1][1]}\t\t{compile_algorithmEntity.container[tokens[2]].attribute.entity_name} {compile_algorithmEntity.container[tokens[2]].attribute.id}")
                #     instructions_line_number += 1  # 下一指令行号
                #     continue
                #     pass  # if
                # ## 如果是连续的指令`if XXX goto XXX`，则编译判别条件
                # if tokens[0] == 'if' and tokens[2] == 'goto':
                #     instructions.append((instructions_line_number, tokens[0], compile_algorithmEntity.condition[tokens[1]], tokens[2], compile_algorithmEntity.container[tokens[3]].attribute.id))  # 生成指令。但是该指令之内容是文本形式的判别条件，需要在执行过程时再解析。
                #     logging.debug(f"{instructions[instructions_line_number - 1][0]}\t{instructions[instructions_line_number - 1][1]}\t\t{tokens[1]}\t\t{instructions[instructions_line_number - 1][3]}\t\t{compile_nodeEntity.attribute.entity_name} {compile_nodeEntity.attribute.id}")
                #     instructions_line_number += 1  # 下一指令行号
                #     continue
                #     pass  # if
                # ## 如果是根节点之指令`define process xxx`，则编译成`start process xxx`
                # if tokens[0] == 'define' and tokens[1] == 'process':
                #     instructions.append((instructions_line_number, 'start process', compile_nodeEntity.attribute.id))
                #     logging.debug(f"{instructions[instructions_line_number - 1][0]}\t{instructions[instructions_line_number - 1][1]}\t\t{compile_nodeEntity.attribute.entity_name} {compile_nodeEntity.attribute.id}")
                #     instructions_line_number += 1  # 下一指令行号
                #     continue
                #     pass  # if
                # ## 如果是根节点之指令`end define xxx`，则编译成`end process xxx`
                # if tokens[0] == 'end' and tokens[1] == 'define':
                #     instructions.append((instructions_line_number, 'end process', compile_nodeEntity.attribute.id))
                #     logging.debug(f"{instructions[instructions_line_number - 1][0]}\t{instructions[instructions_line_number - 1][1]}\t\t{compile_nodeEntity.attribute.entity_name} {compile_nodeEntity.attribute.id}")
                #     instructions_line_number += 1  # 下一指令行号
                #     continue
                #     pass  # if
                pass  # for
            pass  # for
        return instructions
        pass  # def

    pass  # class

```



## 处理实体过程相关的代码



这里提供了递归版（旧版）的基于节点组件的`process_entity_by_node_component`之核心代码与基于过程组件和容器组件的`process_entity_by_process_and_container_component`之核心代码。



### `process_entity_by_process_and_container_component`算法



- [ ] TODO待续。



### `process_entity_by_process_and_container_component`代码



- [ ] TODO待续。

### `process_entity_by_node_component`算法：

特征变量`content_type`表示节点之内容类型。取值如下：
- `content_type = {"process content"}`表示是过程内容节点。目前的过程节点只有两个特殊的节点：开始节点`node_START`、结束节点`node_END`；
- `content_type = {"algorithm content"}`表示是算法内容节点。这类节点承载具体的算法内容；

特征变量`node_type`表示节点之类型。取值表示为集合。集合元素如下：
- `"content node"`表示是内容类型节点；
- `"container node"`表示容器类型节点；
- `"process node"`表示过程类型节点；

特征变量`process_state`表示当前节点处理状态，如果用可视化标记节点颜色表示标记状态，那么：

- 标记是白色`process_state == "has not process"`说明还没处理过该节点，也没有在处理；
- 标记是绿色`process_state == "process now"`说明正在处理该节点；
- 标记是黄色`process_state == "process inner"`说明正在处理该节点之内层节点；
- 标记是红色`process_state == "has processed"`说明已经处理过该节点，但是不表示接下来不会再准备处理该节点；

处理单个节点之过程：

1. 对于准备处理的某一个节点`node_XX`来说，判断其类型：
	- 如果是过程内容节点`node_START`：
	  1. 节点`node_START`标记为绿色；
	  2. 处理节点`node_START`时，标记为红色；
	  3. 跳出到外一层节点`node_XX_outer`；
	- 如果是算法内容和非内容类型的节点（暨非终端节点），则：
	  1. 节点`node_XX`标记为绿色；
	  2. 处理容器内部节点`node_START`（此时意味着处理容器内之内容）；
	  3. 标记`node_XX`为黄色；
	  4. 【步骤1】：根据条件获取`node_XX`之容器之过程之下一个待处理的节点之名称`node_NEXT_name`；
	  5. 判断`node_NEXT_name`是不是结束节点，如果不是就继续，否则跳转到【步骤2】；
	  6. 根据`node_NEXT_name`匹配节点`node_NEXT`；
	  7. 处理容器内部节点`node_NEXT`；
	  8. 跳转到【步骤1】；
	  9. 【步骤2】：处理容器内部节点`node_NEXT`；
	  10. 标记`node_XX`为红色；
	  11. 跳出到外一层节点`node_XX_outer`；
	- 如果是算法内容和内容类型的节点（暨终端节点，承载了具体的算法内容），则：
	  1. 标记为绿色
	  2. 处理该节点；
	  3. 处理之后，标记为红色；
	  4. 跳出到外一层节点`node_XX_outer`；
	- 如果是过程内容节点`node_END`则：
	  1. 节点`node_END`标记为绿色；
	  2. 处理节点`node_END`时，标记为红色；
	  3. 跳出到外一层节点`node_XX_outer`；



### `process_entity_by_node_component`



> 注意：
>
> 这里是基于递归版本的直接处理节点组件之内容的算法。后续可能会写非递归版本的。



```python

    @classmethod
    def process_entity_by_node_component(cls, node: Entity, A: Agent, A_data: AgentDataCollection, para: dict, env: dict):
        """
        处理所有类型的实体，通过节点组件。

        TODO：HACK：目前采用的是以栈的形式处理，这样的缺点是受到python自带的栈深度限制。后续方便的话要改成用遍历动态多叉树生成序列的形式处理。
        NOTE：这里略去了功能：对特殊节点调用`Excuter`。因为就目前的程序来说，没必要进一步复杂化，直接在`Processor`内处理即可。

        Args:
            node (Entity): 节点实体（NOTE：本函数中，特指节点实体而非算法实体。在这里，算法实体简称以`entity`。）
            A (Agent): Agent群变量
            A_data (AgentDataCollection): Agent群变量之数据
            para (dict): 参数变量
            env (dict): 环境变量

        Returns: entity: 算法实体, A: Agent群变量, para: 参数变量, env: 环境变量, A_data: Agent群变量之数据

        """

        ## 如果实体之节点之类型是 content node，且内容之类型是 {"algorithm content"}，则处理：
        if node.attribute.node_type == {"content node"} and node.attribute.content_type == {"algorithm content"}:
            ## 设置临时变量
            b = (A.BB.on | A.BB.off)  # BB示性变量
            ib = (A.BB.on | A.BB.off) & (A.BB.on | A.BB.off).T  # IB示性变量

            # ## 执行终端节点内容 #BUG
            # A = Executer.execute_terminal_entity(A, A_data, para, env, node)
            #
            # ## 收集数据
            # A_data, env = Collector.collect(A, A_data, env)

            ## 执行终端节点内容
            if env['state_of_schedule'] == StateOfScheduleEnum.collecting:
                env = Scheduler.schedule(env, node)
                if env['state_of_schedule'] == StateOfScheduleEnum.running:
                    A, A_data, env = Executer.execute_terminal_entity(A, A_data, para, env, node)

            # ## 执行终端节点内容
            # if env['state_of_schedule'] == StateOfScheduleEnum.running:
            #     A, A_data, env = Executer.execute_terminal_entity(A, A_data, para, env, node)

            ## 标记为已经处理过
            node.attribute.other['process_state'] = "has processed"

            pass  # if

        ## 如果实体之节点之类型是 {"process node", "container node"}，且内容之类型是 {"algorithm content"} 或者 {"model content"} ，则处理：
        if (
                node.attribute.node_type == {"process node", "container node"} and node.attribute.content_type == {"algorithm content"}
        ) or (
                node.attribute.node_type == {"process node", "container node"} and node.attribute.content_type == {"model content", "algorithm content"}
        ):
            ## 处理节点组件内之当前节点实体
            node.attribute.other['process_state'] = "process now"  # 标记为正在处理
            entity = node.content  # 获取节点实体对应的算法实体
            inner_node_name = entity.node['node_START'].attribute.entity_name
            inner_node = entity.node[inner_node_name]  # 获取该节点内层之节点
            inner_node, A, A_data, para, env = Executer.execute_branch_entity(inner_node, A, A_data, para, env)  ## 执行开始节点实体
            inner_node.attribute.other['process_state'] = "has processed"
            node.attribute.other['process_state'] == "process inner"  # 标记节点之处理状态为处理内层节点
            inner_forward_node = inner_node.process[0]['direction']  # 获取开始节点之前向节点
            logging.debug("        方向是【节点：%s，算法：%s %s】", inner_forward_node.attribute.entity_name, inner_forward_node.content.attribute.entity_name, inner_forward_node.content.attribute.text_name)

            ## 继续循环处理该节点之内层的前向的节点，直到处理完结束节点为止。
            while not (inner_forward_node.attribute.other['process_state'] == "has processed" and inner_forward_node.attribute.entity_name == "node_END"):
                ## 处理过程之内容（#NOTE：在设计的时候，就应该保证，同一个`arrow`之各个条件里，只能有一个条件是`True`，然后被处理于后续的时候）
                if inner_forward_node.attribute.node_type == {"content node"} and inner_forward_node.attribute.content_type == {"algorithm content"}:
                    A, A_data, env = Executer.execute_terminal_entity(A, A_data, para, env, inner_forward_node)  ## 执行该节点之内层的前向的节点实体
                elif (
                        inner_forward_node.attribute.node_type == {"process node", "container node"} and inner_forward_node.attribute.content_type == {"algorithm content"}
                ) or (
                        inner_forward_node.attribute.node_type == {"process node", "container node"} and inner_forward_node.attribute.content_type == {"model content"}
                ):
                    inner_forward_node, A, A_data, para, env = Executer.execute_branch_entity(inner_forward_node, A, A_data, para, env)  ## 执行该节点之内层的前向的节点实体
                else:
                    ## 如果是开始节点
                    if inner_forward_node.attribute.entity_name == "node_START":
                        inner_forward_node.attribute.other['process_state'] = "has processed"
                        pass  # if
                    ## 如果是结束节点
                    if inner_forward_node.attribute.entity_name == "node_END":
                        inner_forward_node.attribute.other['process_state'] = "has processed"
                        pass  # if
                    pass  # if

                ## 处理流向
                conditions = []  # 条件结果列表
                if inner_forward_node.process.__len__() != 0:
                    for arrow in inner_forward_node.process:  ## 判断每个条件
                        condition = eval(arrow['condition'])  # 计算条件值
                        logging.debug("        条件【%s】是 %s", arrow['condition'], condition)
                        conditions.append(condition)
                        pass  # for
                    inner_forward_node = inner_forward_node.process[conditions.index(True)]['direction']  # 判断在当前条件下，符合条件的前向的节点
                    logging.debug("        方向是【节点：%s，算法：%s %s】", inner_forward_node.attribute.entity_name, inner_forward_node.content.attribute.entity_name, inner_forward_node.content.attribute.text_name)
                    pass  # if
                else:  # 结束节点
                    pass  # if

                pass  # while

            node.attribute.other['process_state'] == "has processed"  # 标记节点之处理状态为处理完成 #BUG

        ## 如果实体之节点之类型是 {"process node"}，且内容之类型是 {"process content"}（NOTE：开始节点`node_START`、结束节点`node_END`），则处理：
        if node.attribute.node_type == {"process node"} and node.attribute.content_type == {"process content"}:

            if node.attribute.entity_name == "node_START":  ## 如果是开始节点
                node.attribute.other['process_state'] = "has processed"
                pass  # if
            elif node.attribute.entity_name == "node_END":  ## 如果是结束节点
                node.attribute.other['process_state'] = "has processed"
                pass  # if

            pass  # if

        return node, A, A_data, para, env
        pass  # method

    # @classmethod
    # def process_processEntity(cls, entity: Entity):
    #     """
    #     Args:
    #         entity ():
    #     """
    #     pass  # method

    @classmethod
    def process_conditionEntity(cls, entity: Entity):  # NOW 处理过程类型的实体之条件
        conditions = []  # 条件列表
        for (i, out_flow_entity) in enumerate(entity.process):  ## 判断每个条件
            condition = eval(out_flow_entity['condition']) if out_flow_entity['condition'] is not None else None  # NOTE 其实判断None这个条件是多余的，因为
            logging.debug("        条件【%s】是 %s", out_flow_entity['condition'], condition)
            conditions.append(condition)
        out_flow_entity = entity.process[conditions.index(True)]['flow']

        return conditions, out_flow_entity
        pass  # method

```



## 执行实体过程相关的代码



### executer.py



- [ ] TODO需要改进



```python
"""
执行机
"""

from .import logging
from .core.define.define_agentDataCollection import AgentDataCollection
from .core.define.define_agents import Agent
from .core.define.define_entity import Entity
from .core.define.define_type import *

pass  # end import


class Executer:
    """
    执行机
    """

    @classmethod
    def execute_branch_entity(cls, node: Entity, agent: Agent, agentData: AgentDataCollection, para: dict, env: dict):
        """
        执行分支实体。
        输入参数将被直接修改。

        Args:
            node (Entity): 节点实体（NOTE：本函数中，特指节点实体而非算法实体。算法实体表示`entity`。）
            agent (Agent): Agent群变量
            agentData (AgentDataCollection): Agent群变量之数据
            para (dict): 参数变量
            env (dict): 环境变量

        Returns: modelEntity, A, para, env, agentData

        """
        entity = node.content  # 获取节点实体对应的算法实体

        # if node.attribute.node_type == {"process node", "container node"}:
        logging.debug("- 入过程：%s %s", entity.attribute.text_name, entity.attribute.entity_name)

        node, agent, agentData, para, env = entity.execute(node, agent, agentData, para, env)

        # if node.attribute.node_type == {"process node", "container node"}:
        logging.debug("- 出过程：%s %s", entity.attribute.text_name, entity.attribute.entity_name)

        return node, agent, agentData, para, env
        pass  # method

    @classmethod
    def execute_terminal_entity(cls, A: Agent, b: StateType, ib: StateType, para: dict, env: dict, node: Entity):
        """
        执行终端实体。
        输入参数将被直接修改。

        Args:
            A (Agent): Agent群变量
            b (StateType): 示性向量
            ib (StateType): 邻接矩阵示性矩阵
            para (dict): 参数变量
            env (dict): 环境变量
            node (Entity): 节点实体（NOTE：本函数中，特指节点实体而非算法实体。算法实体表示`entity`。）

        Returns: agent

        """
        entity = node.content  # 获取节点实体对应的算法实体

        logging.debug("- - 开始阶段：%s %s", entity.attribute.text_name, entity.attribute.entity_name)

        env['round'] += 1  # 计次回合数

        A.BB, A.BI = entity.execute(A.BB, A.BI, b, ib, para, env)

        logging.debug("- - 结束阶段：%s %s", entity.attribute.text_name, entity.attribute.entity_name)

        return A
        pass  # method

    # @classmethod
    # def execute_special_entity(cls, node:Entity): #HACK 暂时不需要使用
    #     """
    #     执行特殊实体。特殊实体指：开始节点实体、结束节点实体。
    #
    #     Args:
    #         node (Entity): 节点实体（NOTE：本函数中，特指节点实体而非算法实体。算法实体表示`entity`。）
    #
    #     Returns: node
    #
    #     """
    #
    #     entity = node.content  # 获取节点实体对应的算法实体
    #
    #     # if node.attribute.node_type == {"process node", "container node"}:
    #     logging.debug("- 入过程：%s %s", entity.attribute.text_name, entity.attribute.entity_name)
    #
    #     node, agent, agentData, para, env = entity.execute(node)
    #
    #     # if node.attribute.node_type == {"process node", "container node"}:
    #     logging.debug("- 出过程：%s %s", entity.attribute.text_name, entity.attribute.entity_name)
    #
    #     pass  # method

    pass  # class

```





## 管理实体相关的代码







### 定义实体



```python
"""
定义实体
"""

from .core.define.define_component import *

pass  # end import


class Entity:
    """
    实体。

    实体是系统中的基本单元。实体是一个有特征的对象，它可以是一个节点、一个内容、一个容器、一个过程、一个条件、一个执行器。

    实体的特征是由实体的组件决定的。实体的组件包括：实体特征、实体内容、实体容器、实体过程、实体节点、实体条件、实体执行器。

    包含的组件有：

    - attribute: AttributeComponentType: 实体特征
    - content: Union[ContentComponent, None]: 实体内容
    - process: Union[ProcessComponent, None]: 实体过程
    - container: Union[ContainerComponent, None]: 实体容器
    - condition: Union[ConditionComponent, None]: 实体条件
    - execute: Union[ExecuteComponent, None]: 实体执行器
    - node: Union[NodeComponent, None]: 实体节点
    """

    attribute: AttributeComponent
    content: Union[ContentComponent, None]
    process: Union[ProcessComponent, None]
    container: Union[ContainerComponent, None]
    condition: Union[ConditionComponent, None]
    execute: Union[ExecuteComponent, None]
    node: Union[NodeComponent, None]

    def __init__(self, entityData: Any = None, **kwargs):
        """
        初始化。创建实体

        Args:
            entityData (Any): 事先设置好的实体数据
            attribute (AttributeComponentType): 实体特征
            **kwargs (): 其它参数

        > [!note]
        > 以下是赋值的要求：

        - 如果`entityData`不为空，那么要求`**kwargs`设置为空；

        - 如果`entityData`不为空，那么要求`entityData`数据必须符合格式要求。

        - 如果`entityData`为空且`**kwargs`不为空，那么要求`**kwargs`里面不能有`entityData`；

        - `**kwargs`之所有键名应该与实体类在各组件字段名称保持一致，除了`attribute.other`字段之外；

        - 最好不要在实例化`entity`时赋值`attribute.other`字段。建议在实例化之后，再赋值`attribute.other`字段；

        - 当所有参数都为空的时候，将创建一个具有随机`id`、随机`name`的空实体。


        Returns:
            entity (Entity): 实体

        """

        ## 如果`entityData`不为空，那么直接设置`entityData`数据，否则设置`**kwargs`数据。
        if entityData is not None:
            kwargs = None
            self.attribute = AttributeComponent(attribute=entityData['attribute'])  # HACK 如果`entityData['attribute']`为空，那么entityData数据不符合要求。这里并未给出检查条件。
            self.content = entityData['content']
            self.execute = entityData['execute']
            self.process = entityData['process']
            self.container = entityData['container']
            self.condition = entityData['condition']
            self.node = entityData['node']
            # self.content = ContentComponent(content=entityData['content'])
            # self.execute = ExecuteComponent(execute=entityData['execute'])
            # self.process = ProcessComponent(process=entityData['process'])
            # self.container = ContainerComponent(container=entityData['container'])
            # self.condition = ConditionComponent(condition=entityData['condition'])
            # self.node = NodeComponent(node=entityData['node'])
        elif kwargs is not None:  # 如果`attribute`不为空，那么直接设置`attribute`数据至`AttributeComponent`，否则设置`**kwargs`至`AttributeComponent`。
            if 'attribute' in kwargs.keys():  # 有`attribute`组件，就直接通过`attribute`组件创建`attribute`组件
                self.attribute = AttributeComponent(attribute=kwargs['attribute'])
            elif 'attribute' not in kwargs.keys():  # 没有`attribute`组件，就通过其它键值对创建`attribute`组件
                self.attribute = AttributeComponent(attribute=None, **kwargs)
                pass  # if
            ## 一次创建其它组件
            self.content = kwargs['content'] if 'content' in kwargs.keys() else None
            self.execute = kwargs['execute'] if 'execute' in kwargs.keys() else None
            self.process = kwargs['process'] if 'process' in kwargs.keys() else None
            self.container = kwargs['container'] if 'container' in kwargs.keys() else None
            self.condition = kwargs['condition'] if 'condition' in kwargs.keys() else None
            self.node = kwargs['node'] if 'node' in kwargs.keys() else None
            # self.content = ContentComponent(content=kwargs['content']) if kwargs['content'] in kwargs.keys() else ContentComponent(None)
            # self.execute = ExecuteComponent(execute=kwargs['execute']) if kwargs['execute'] in kwargs.keys() else ExecuteComponent(None)
            # self.process = ProcessComponent(process=kwargs['process']) if kwargs['process'] in kwargs.keys() else ProcessComponent(None)
            # self.container = ContainerComponent(container=kwargs['container']) if kwargs['container'] in kwargs.keys() else ContainerComponent(None)
            # self.condition = ConditionComponent(condition=kwargs['condition']) if kwargs['condition'] in kwargs.keys() else ConditionComponent(None)
            # self.node = NodeComponent(node=kwargs['node']) if kwargs['node'] in kwargs.keys() else NodeComponent(None)
        else:  # HACK其实这种情况不可能发生。因为已经自动生成了`id`和`name`。
            self.attribute = AttributeComponent(None)
            self.content = None
            self.execute = None
            self.process = None
            self.container = None
            self.condition = None
            self.node = None
            # self.content = ContentComponent(None)
            # self.execute = ExecuteComponent(None)
            # self.process = ProcessComponent(None)
            # self.container = ContainerComponent(None)
            # self.condition = ConditionComponent(None)
            # self.node = NodeComponent(None)
            pass  # if

        pass  # def

    pass  # class

```



### 实体管理机



```python
"""
实体管理机
"""

from . import np, logging
from .core.define.define_component import *
from .core.define.define_entity import Entity
from .tools.tools import Tools

pass  # end import


class EntityManager:
    """
    实体管理机。

    其中可用变量如下：
    entities：实体字典。键是实体`id`，值是实体。
    algorithmEntities：算法实体字典。键是实体名称`entity_name`，值是实体。
    modelEntities：模型实体字典。键是实体名称`entity_name`，值是实体。
    treeEntities：树实体字典。键是实体`id`，值是实体。

    管理所有存在变量空间的实体变量。
    """

    entities: dict = {}  # 实体字典。键是实体`id`，值是实体。
    algorithmEntities: dict = {}  # 算法实体字典。键是实体名称`entity_name`，值是实体。
    modelEntities: dict = {}  # 模型实体（模型节点实体）字典。键是实体名称`entity_name`，值是实体。
    modelAlgorithmEntities: dict = {}  # 模型算法字典。键是实体名称`entity_name`，值是实体。
    treeEntities: dict = {}  # 树实体字典。键是实体`id`，值是实体。

    @classmethod
    def create_entity(cls, entityData: Any = None, **kwargs):
        """
        创建一个新实体。

        新实体可以传入参数为空，但是生成的新实体一定具有两个非空的属性：`attribute.id`、`attribute.entity_name`。其中，`attribute.id`是实体唯一标识符，每一个实体之`id`都不重复。

        有以下方式创建实体：

        1. 通过传入实体数据创建实体。

        2. 通过传入任意的键值对到`**kwargs`创建实体。

        如果没有手动设置新建的节点`id`，那么自动设置一个`id`。

        其中，`id`开头为"user"的为保留字段，用于表示用户自定义的`id`。

        如果没有手动设置新建的节点名称，那么自动使用`id`作为名称。

        如果新建的节点`id`与变量区中现有的节点的`id`重复，或者前4位是`"user"`，那么就重新生成新的不重复的`id`，然后返回相应的信息。

        创建一个新实体之后，根据实体之节点属性`attribute.node_type`、实体之内容属性`attribute.content_type`，加入新建的实体`id`到实体列表。

        **kwargs: 其它参数

        其中，推荐手动设置以下参数：

        - attribute (AttirbuteComponentType) = None: 实体属性

        - id (Union[int, str,None]) = None: 实体id

        - name: Union[str,None] = None: 实体名称

        - content: Union[str, Any] = None: 实体内容


        Args:
            entityData (Any): 已经事先设置好了的实体数据
            **kwargs: 其它参数

        Returns:
            Entity: 新节点

        """

        ## 如果传入了实体数据，那么就直接创建实体，否则根据传入的其他参数创建实体
        if entityData is not None:
            entity = Entity(entityData=entityData)
        else:
            ## 判别是否需要创建新的`id`、`kwargs`是否有`id`键
            if 'id' in kwargs.keys():  # 如果有键`id`
                is_kwargs_has_key_id = True
                if kwargs['id'] is None:  # 如果`id`是空的，那么就自动生成一个新的`id`
                    is_need_create_new_id = True
                else:  # 如果`id`不是空的，那么就考虑使用手动设置的`id`
                    if cls._distinguish_is_need_create_new_id(kwargs['id']):  # 判断是否需要自动生成`id`
                        logging.info(f"手动设置的节点id={kwargs['id']}无效，需要重新生成一个新的节点id")
                        is_need_create_new_id = True  # 手动设置的`id`无效，需要重新生成`id`
                    else:
                        is_need_create_new_id = False  # 手动设置的`id`有效，不需要重新生成`id`
                        pass  # if
                    pass  # if
            else:  # 如果没有键`id`，则需要自动生成一个`id`
                is_kwargs_has_key_id = False
                is_need_create_new_id = True
                pass  # if

            ## 根据判别结果设置`id`
            if is_need_create_new_id:  # 如果需要创建新的`id`
                new_id = Tools.generate_unique_identifier()
                while cls._distinguish_is_need_create_new_id(new_id):  # 判断是否需要重新创建`id`
                    new_id = Tools.generate_unique_identifier()
                    pass  # while
                logging.info(f"自动生成一个新的节点id={new_id}")
            else:
                new_id = str(kwargs['id']).zfill(8)  # 使用手动设置的节点`id`
                pass  # if

            ## 根据判别结果更新`kwargs`之`id`
            if is_kwargs_has_key_id:  # 如果有键`id`
                kwargs['id'] = new_id
            else:  # 如果没有键`id`
                kwargs.update({'id': new_id})
                pass  # if

            ## 设置`entity_name`
            ## 判别是否需要创建新的`entity_name`、`kwargs`是否有`entity_name`键
            if 'entity_name' in kwargs.keys():  # 如果有键`entity_name`
                is_kwargs_has_key_entity_name = True
                if kwargs['entity_name'] is None:  # 如果没有手动设置`entity_name`，就用`id`作为`entity_name`
                    is_need_create_new_name = True
                else:
                    is_need_create_new_name = False
                    pass  # if
            else:
                is_kwargs_has_key_entity_name = False
                is_need_create_new_name = True
                pass  # if

            ## 根据判别结果设置`entity_name`
            if is_need_create_new_name:  # 如果需要创建新的`entity_name`
                new_name = f"name_{new_id}"
                logging.info(f"未设置name，自动命名为名称：「{new_name}」。")
            else:
                new_name = kwargs['entity_name']
                pass  # if

            ## 根据判别结果更新`kwargs`之`entity_name`
            if is_kwargs_has_key_entity_name:  # 如果有键`entity_name`
                kwargs['entity_name'] = new_name
            else:  # 如果没有键`entity_name`
                kwargs.update({'entity_name': new_name})

            ## 根据上述判断，创建实体
            entity = Entity(entityData=None, **kwargs)

            # ## 设置节点类型
            # is_need_set_nodeType = None  # 初始化是否需要设置节点类型
            # if 'node_type' in kwargs.keys():  # 如果有键`node_type`，并且有值，就设置节点类型，否则不设置。
            #     if kwargs['node_type'] is None:
            #         is_need_set_nodeType = False
            #     else:
            #         is_need_set_nodeType = True
            #         pass  # if
            # else:
            #     is_need_set_nodeType = False
            #     pass  # if
            #
            # ## 根据上述判断，创建实体
            # if is_need_set_nodeType:
            #     entity = Entity(entityData=None, id=new_id, entity_name=new_name, node_type=kwargs['node_type'])
            # else:
            #     entity = Entity(entityData=None, id=new_id, entity_name=new_name)
            #     pass  # if

        pass  # if

        ## 将新建的实体id加入各个实体列表
        cls.add_entity(entity)
        cls.add_algorithmEntity(entity)
        cls.add_modelEntity(entity)
        cls.add_modelAlgorithmEntity(entity)
        cls.add_treeNodeEntity(entity)
        return entity

    @classmethod
    def delete_entity(cls, entity: Entity):
        """
        删除实体。

        注意：永久删除实体。

        Args:
            entity (Entity): 实体

        Returns:

        """

        id = entity.attribute.id
        name = entity.attribute.entity_name

        ## 分别从各实体列表中移除实体
        if id in cls.entities.keys():
            cls.entities.pop(id)
            logging.info(f"已从 entities 移除实体")
        if name in cls.algorithmEntities.keys():
            cls.algorithmEntities.pop(name)
            logging.info(f"已从 algorithmEntities 移除实体")
        if name in cls.modelEntities.keys():
            cls.modelEntities.pop(name)
            logging.info(f"已从 modelEntities 移除实体")
        if id in cls.treeEntities.keys():
            cls.treeEntities.pop(id)
            logging.info(f"已从 treeEntities 移除实体")

        ## 删除实体
        del entity
        logging.info(f"已删除实体。id：{id}，名称：{name}。")

        pass  # def

    @classmethod
    def add_entity(cls, entity: Entity):
        """
        添加新建的实体到实体字典，键是实体`id`，值是实体。

        Args:
            entity (Entity): 实体

        Returns:

        """
        cls.entities.update({entity.attribute.id: entity})
        logging.info(f"已添加实体到 entities。id：「{entity.attribute.id}」，名称：「{entity.attribute.entity_name}」。")
        pass  # def

    @classmethod
    def add_treeNodeEntity(cls, entity: Entity):
        """
        添加树实体到树实体字典。键是实体`id`，值是实体。

        Args:
            entity (Entity): 实体

        Returns:

        """
        if (
                entity.attribute.node_type == {"tree node"}
        ):
            cls.treeEntities.update({entity.attribute.id: entity})
            logging.info(f"已添加实体到 treeEntities。id：「{entity.attribute.id}」，名称：「{entity.attribute.entity_name}」。")
        pass  # def

    @classmethod
    def add_algorithmEntity(cls, entity: Entity):
        """
        添加算法实体到算法实体字典。键是实体名称`entity_name`，值是实体。

        Args:
            entity (Entity): 实体

        Returns:

        """
        if (
                entity.attribute.node_type == {"container node", "process node"} and
                entity.attribute.content_type == {"algorithm content"}
        ) or (
                entity.attribute.node_type == {"container node", "process node"} and
                entity.attribute.content_type == {"model content", "algorithm content"}
        ) or (
                entity.attribute.node_type == {"content node"} and
                entity.attribute.content_type == {"algorithm content"}
        ) or (
                entity.attribute.node_type == {"process node"} and
                entity.attribute.content_type == {"process content"}
        ):
            cls.algorithmEntities.update({entity.attribute.entity_name: entity})
            logging.info(f"已添加实体到 algorithmEntities。id：「{entity.attribute.id}」，名称：「{entity.attribute.entity_name}」。")
        pass  # def

    @classmethod
    def add_modelAlgorithmEntity(cls, entity: Entity):
        """
        添加模型算法实体到模型算法实体字典。键是实体名称`entity_name`，值是实体。

        Args:
            entity (Entity): 实体

        Returns:

        """

        # if (
        #         entity.attribute.node_type == {"container node"} and
        #         entity.attribute.content_type == {"model content", "node content"}
        # ):
        if (
                entity.attribute.node_type == {"container node", "process node"} and
                entity.attribute.content_type == {"model content", "algorithm content"}
        ):
            cls.modelAlgorithmEntities.update({entity.attribute.entity_name: entity})
            logging.info(f"已添加实体到 modelAlgorithmEntities。id：「{entity.attribute.id}」，名称：「{entity.attribute.entity_name}」。")
        pass  # def

    @classmethod
    def add_modelEntity(cls, entity: Entity):
        """
        添加模型实体（模型节点实体）到模型实体字典。键是实体名称`entity_name`，值是实体。

        Args:
            entity (Entity): 实体

        Returns:

        """

        # if (
        #         entity.attribute.node_type == {"container node", "process node"} and
        #         entity.attribute.content_type == {"model content", "algorithm content"}
        # ) or (
        #         entity.attribute.node_type == {"container node"} and
        #         entity.attribute.content_type == {"model content", "node content"}
        # ):
        if (
                entity.attribute.node_type == {"container node"} and
                entity.attribute.content_type == {"model content", "node content"}
        ):
            cls.modelEntities.update({entity.attribute.entity_name: entity})
            logging.info(f"已添加实体到 modelEntities。id：「{entity.attribute.id}」，名称：「{entity.attribute.entity_name}」。")
        pass  # def

    @classmethod
    def _distinguish_is_need_create_new_id(cls, id: Union[str, None]) -> bool:
        """
        判断是否需要创建新的实体`id`。

        Args:
            id (Union[str, None]): 实体`id`

        Returns:
            bool: 是否需要创建新的实体`id`

        """
        if id in cls.entities.keys():
            logging.warning(f"节点id={id}已存在！")
            return True
        elif id[:4].lower() == "user":
            logging.warning(f"节点id={id}以「user」开头！")
            return True
        else:
            return False
            pass  # if

        pass  # def

    pass  # class

```



## 组织实体数据结构相关的代码



### 栈数据结构



```python
"""
栈数据结构。

#HACK 没有做覆盖性的单元测试。目前只要求能够在主程序中正确运行就好。

"""

from . import Union
from .core.operations.entity_manager import EntityManager
from .core.define.define_entity import Entity


class Stack:
    """
    栈数据结构。

    该数据结构要求输入存储`Entity`之`id`或者`Entity`自身。但是可以通过`EntityManager`实现判断数据类型然后只在栈中存储`Entity`之`id，并且通过`id`返回`Entity`数据。

    """

    def __init__(self):
        """
        初始化。
        """
        self.content = []
        pass  # def

    def is_empty(self):
        """
        判断栈是否为空。
        Returns:
            bool: 如果是空，则返回True，否则返回False。

        """
        return len(self.content) == 0
        pass  # def

    def push(self, items: Union[str, list, Entity]):
        """
        压入元素入栈。

        Args:
            items (Union[str, Entity]): 元素。可以是`Entity`之`id`或者`Entity`自身。

        """
        if isinstance(items, list):
            items_list = items
        else:
            items_list = [items]
            pass  # if

        if isinstance(items_list[0], str):
            self.content.extend(items_list)
        elif isinstance(items_list[0], Entity):
            self.content.extend([item.attribute.id for item in items_list])
            pass  # if

        pass  # def

    def pop(self) -> Entity:
        """
        弹出元素出栈。
        Returns:
            栈顶元素。
        """
        if self.is_empty():
            raise Exception("Stack 是空的")
        item_id = self.content.pop()
        return EntityManager.entities[item_id]
        pass  # def

    def peek(self) -> Entity:
        """
        返回栈顶元素，但是不弹出元素。
        Returns:
            栈顶元素。
        """
        if self.is_empty():
            raise Exception("Stack 是空的")
        item_id = self.content[-1]
        return EntityManager.entities[item_id]
        pass  # def

    def size(self) -> int:
        """
        返回栈的大小。
        Returns:
            栈的大小。
        """
        return len(self.content)
        pass  # def

    def print_stack(self, mode='return'):
        """
        打印栈中的元素，以元素名称的形式。

        Args:
            mode (str): 打印模式。可以是`return`或者`print`。如果是`return`，则返回字符串；如果是`print`，则直接打印。默认是`return`。

        """
        if not self.is_empty():
            if mode == 'return':
                return '[' + ', '.join([EntityManager.entities[item].attribute.entity_name for item in self.content]) + ']'
            elif mode == 'print':
                names = [EntityManager.entities[item].attribute.entity_name for item in self.content]
                print(*names, sep=", ", end="")
                pass  # if
        else:
            if mode == 'return':
                return '[]'
            elif mode == 'print':
                print('[]')
                pass  # if
            pass  # if

        pass  # def

```







### 树数据结构





```python
"""
树数据结构

#HACK 没有做覆盖性的单元测试。目前只要求能够在主程序中正确运行就好。

"""
from . import Union, logging
from .core.define.define_entity import Entity
from .core.operations.entity_manager import EntityManager


class Tree:
    """
    树结构类。

    用于构建、遍历一棵树。
    """
    root_node: Entity  # 根节点

    def __init__(self):
        """
        初始化根节点
        """
        self.root_node = EntityManager.create_entity(entity_name='root', node_type={"tree node"})  # 创建根节点
        EntityManager.add_treeNodeEntity(self.root_node)  # 将根节点添加到树节点实体字典中
        self.root_node.attribute.other['parent'] = None
        pass  # def

    def get_root(self) -> Entity:
        """
        获取树之根节点
        Returns:

        """
        return self.root_node
        pass  # def

    def get_parent(self, item: Union[str, Entity]) -> Union[Entity, None]:
        """
        根据当前节点获取父节点。但是不包含父节点之父节点。

        Args:
            item (Union[str, Entity]): 当前节点。可以取其`id`或者`Entity`自身。

        Returns:
            如果是非根节点，则返回父节点，否则返回空
        """

        node = self._distinguish_node_format_and_type(item)

        if node is not None:
            return node.attribute.other['parent']
        else:
            logging.info("当前节点是根节点，没有父节点。")
            return None

        pass  # def

    def get_node_by_id(self, id: str) -> Union[Entity, None]:
        """
        根据树节点`id`获取树节点

        Args:
            id (str): 节点`id`

        Returns:
            Entity: 节点实体，如果没有找到，则返回空。

        """
        return EntityManager.treeEntities[id] if id in EntityManager.treeEntities else None
        pass  # def

    def get_content(self, item: Union[str, Entity]):
        """
        获取当前节点之内容。

        Args:
            item (Union[str, Entity]): 如果是`str`，则是节点`id`；如果是`Entity`，则是节点实体。

        Returns:
            Entity.content: 节点内容。
        """

        node = self._distinguish_node_format_and_type(item)

        return node.content
        pass  # def

    def get_children(self, item: Union[str, Entity]):
        """
        获取当前节点之所有子节点。但是不包含所有子节点之子节点。

        Args:
            item (Union[str, Entity]): 当前节点。可以取其`id`或者`Entity`自身。

        Returns:
            如果存在子节点，返回子节点字典列表，否则返回空列表。
        """
        node = self._distinguish_node_format(item)

        if node is not None:
            return list(node.container.values()) if node.container is not None else []
        else:
            logging.info("当前节点没有子节点。")
            return []
            pass  # if

        pass  # def

    def get_child(self, item: Union[str, Entity], child_item: Union[str, Entity]) -> Union[Entity, None]:
        """
        根据子节点之`id`获取当前节点之子节点。

        Args:
            item (Union[str, Entity]): 当前节点。可以取其`id`或者`Entity`自身。
            child_item (Union[str, Entity]): 子节点。可以取算法实体之节点实体之`id`、树节点实体`id`、算法实体之节点实体`Entity`自身、树节点实体`Entity`自身。

        Returns:
            如果存在子节点，返回子节点，否则返回空。
        """
        node = self._distinguish_node_format_and_type(item)
        child_node = self._distinguish_node_format_and_type(child_item)

        children = self.get_children(node)

        if children is not None:
            for child in children:
                if child.attribute.id == child_node.attribute.id:
                    result_child_node = child_node
                    break
                else:
                    result_child_node = None
                    pass  # if
                pass  # for
        else:
            logging.info(f"节点{node.attribute.entity_name}不存在任何子节点。")
            return None
            pass  # if

        if result_child_node is not None:
            logging.debug(f"节点{node.attribute.entity_name}之子节点为{result_child_node.attribute.entity_name}。")
            return result_child_node
        else:
            logging.info(f"节点{node.attribute.entity_name}之子节点不存在。")
            return None

        pass  # def

    def create_and_add_node(self, id: Union[str, None] = None, entity_name: Union[str, None] = None, content: Union[Entity, None] = None, parent_item: Union[str, Entity, None] = None) -> Entity:
        """
        创建一个节点，并将其附加到树内的其中一个节点。

        根据`id`和实体名称`entity_name`、创建一个树节点，内容并将其附加到树。

        Args:
            id (Union[str, None]): 节点`id`。如果为空，则自动生成。
            entity_name (str): 节点实体名称。
            content (Union[Entity, None]): 节点内容。如果为空，则创建一个空内容。
            parent_item (Union[str, Entity, None]): 父节点。可以取其`id`或者`Entity`自身。如果为空，则将子节点附加到根节点。

        Returns:
            创建的节点。

        """
        node = EntityManager.create_entity(entityData=None, id=id, entity_name=entity_name, node_type={"tree node"}, content=content)
        self.add_child(child_item=node, parent_item=parent_item)
        return node

        pass  # def

    def add_child(self, child_item: Union[str, Entity, None], parent_item: Union[str, Entity, None] = None):
        """
        附加一个子节点到树。

        如果子节点为空，则创建新子节点，然后附加到根节点。

        如果父节点为空，则将子节点附加到根节点。

        Args:
            child_item (Union[str, Entity]): 子节点。可以取其`id`或者`Entity`自身。
            parent_item (Union[str, Entity, None]): 父节点。可以取其`id`或者`Entity`自身。如果为空，则附加到根节点。

        """
        child_node = self._distinguish_node_format(child_item)
        parent_node = self._distinguish_node_format(parent_item)

        # 如果子节点为空，则创建新子节点，然后附加到根节点
        if child_node is None:
            child_node = self.create_and_add_node(id=None, entity_name=child_item, content=None, parent_item=parent_item)
            pass

        # 如果父节点为空，则将子节点附加到根节点
        if parent_node is None:
            parent_node = self.root_node

        child_node.attribute.other['parent'] = parent_node  # 设置子节点之父节点

        ## 子节点附加到父节点
        if parent_node.container is not None:
            parent_node.container.update({child_node.attribute.entity_name: child_node})
        else:
            parent_node.container = {child_node.attribute.entity_name: child_node}
            pass  # if

        EntityManager.add_treeNodeEntity(child_node)  # 添加到树实体集

        pass  # def

    def add_children(self, childern: list, parent: Union[str, Entity, None]):
        """
        附加列表的所有子节点到树。

        Args:
            childern (list): 子节点列表。可以是`id`列表或者`Entity`列表。
            parent (Entity): 父节点。可以是`id`或者`Entity`。如果为空，则附加到根节点。

        """

        # 如果父节点为空，则将子节点附加到根节点
        childern_nodes = [self._distinguish_node_format(child) for child in childern]
        parent_node = self._distinguish_node_format(parent)

        parent_node = parent_node if parent_node is not None else self.root_node

        for child in childern_nodes:
            child.attribute.other['parent'] = parent_node

        ## 子节点附加到父节点
        if parent_node.container is not None:
            for child in childern_nodes:
                parent_node.container.update({child.attribute.id: child})
        else:
            for child in childern_nodes:
                parent_node.container = {child_node.attribute.id: child_node for child_node in childern}
            pass  # if

        ## 添加到树实体集
        for child in childern_nodes:
            EntityManager.add_treeNodeEntity(child)

        pass

    def find_targetNode_from_sourceNode(self, sourceNode: Entity, targetNode_name: str) -> Union[Entity, None]:
        """
        使用迭代查找节点

        Args:
            sourceNode (Entity): 当前源节点
            targetNode_name (str): 目标节点名称

        Returns:
            Entity: 目标节点，如果找到；否则返回None

        """
        stack = [sourceNode]
        while stack:
            curr_node = stack.pop()
            if curr_node.attribute.entity_name == targetNode_name:
                return curr_node
            stack.extend(reversed(curr_node.container))
        return None
        pass  # def

    def remove_node(self, node: Entity, is_link_children_node: bool = False) -> bool:
        """
        从树中移除节点。

        Args:
            node (Entity): 要移除的节点
            is_link_children_node (bool): 是否连接该节点之子节点到该节点之父节点

        Returns:
            bool: True表示移除成功；False表示移除失败

        """
        if node == self.root_node:
            return False  # 没有父节点，移除失败
        parent = node.attribute.other['parent']
        if not parent:
            return False  # 没有父节点，移除失败
        # 父节点的子节点列表移除该节点
        parent.container.remove(node)
        # 该节点的父节点设置为空
        node.attribute.other['parent'] = None

        # 如果需要移除子节点，则将子节点的父节点设置为当前节点的父节点
        if is_link_children_node:
            for child in node.container:
                child.attribute.other['parent'] = parent
                parent.container.append(child)

        EntityManager.treeEntities.pop(node.attribute.id)  # 从树实体集中移除该节点实体

        return True  # 有父节点，移除成功
        pass  # def

    def preorder_traversal(root_node: Entity) -> list:  # HACK 未做单元测试。虽然需要改成自定义的Stack结构，但是目前不怎么做。
        """
        前序遍历

        Args:
            root_node (Entity): 根节点

        Returns:
            List[Entity]: 遍历结果

        """
        if root_node is None:
            return []

        result = []
        stack = [root_node]
        while stack:
            curr_node = stack.pop()
            result.append(curr_node)
            children = reversed(curr_node.container)
            stack.extend(children)
            pass  # while

        return result
        pass  # def

    def inorder_traversal(root_node: Entity) -> list:  # HACK 未做单元测试。虽然需要改成自定义的Stack结构，但是目前不怎么做。
        """
        中序遍历

        Args:
            root_node (Entity): 根节点

        Returns:
            List[Entity]: 遍历结果

        """
        if root_node is None:
            return []

        result = []
        stack = []
        curr_node = root_node
        while curr_node or stack:
            while curr_node:
                stack.append(curr_node)
                curr_node = curr_node.container[0] if curr_node.container else None
            curr_node = stack.pop()
            result.append(curr_node)
            curr_node = curr_node.container[1] if len(curr_node.container) > 1 else None

        return result
        pass  # def

    def postorder_traversal(root_node: Entity) -> list:  # HACK 未做单元测试。虽然需要改成自定义的Stack结构，但是目前不怎么做。
        """
        后序遍历
        Args:
            root_node (Entity): 根节点

        Returns:
            List[Entity]: 遍历结果

        """
        if root_node is None:
            return []

        result = []
        stack = [(root_node, False)]
        while stack:
            curr_node, visited = stack.pop()
            if visited:
                result.append(curr_node)
            else:
                stack.append((curr_node, True))
                children = reversed(curr_node.container)
                for child in children:
                    stack.append((child, False))

        return result
        pass  # def

    def print_tree(self, node: Union[Entity, None] = None, info: str = 'entity_name', prefix="", _is_tail=True):  # TODO 由于树结构可能会很大，需要改成非递归的方式
        """
        以类似Linux中tree命令的输出结果打印树结构及其相关信息。

        递归编程方式。

        Args:
            node (Entity): 树节点。
            info (str): 要打印的信息。默认为实体名称`entity_name`。

        Returns:

        """

        ## NOTE 基于递归形式的
        if not node:
            node = self.root_node
            pass  # if
        node_info = node.attribute.entity_name
        node_prefix = "└── " if _is_tail else "├── "
        logging.info(prefix + node_prefix + str(node_info))
        child_prefix = prefix + (" " * 8 if _is_tail else "│" + " " * 6)
        if self.get_children(node) is not None:
            child_count = len(self.get_children(node))
            for i, child in enumerate(self.get_children(node)):
                _is_tail = (i == child_count - 1)
                self.print_tree(node=child, info=node_info, prefix=child_prefix, _is_tail=_is_tail)
        else:
            pass  # if

        # node_info = eval('node.attribute.info') #HACK 这个是基于递归形式的，可以提供多个打印信息的。但是还没有完成。
        # node_prefix = "└── " if _is_tail else "├── "
        # logging.info(prefix + node_prefix + str(node_info))
        # child_prefix = prefix + (" " * 8 if _is_tail else "│" + " " * 6)
        # if self.get_children(node) is not None:
        #     child_count = len(self.get_children(node))
        #     for i, child in enumerate(self.get_children(node).values()):
        #         _is_tail = (i == child_count - 1)
        #         self.print_tree(node=child, prefix=child_prefix, _is_tail=_is_tail)
        # else:
        #     pass  # if

        pass  # def

    # def print_tree(self):  # HACK 未能运行起来。后续需要改进。需要广度优先遍历生成前缀字符串。需要前序遍历生成打印顺序。
    #     """
    #     以类似Linux中tree命令的输出结果打印树结构。
    #
    #     非递归编程方式。
    #
    #     Returns:
    #
    #     """
    #     child_prefix = ""
    #     stack = [(self, "", 0, True)]
    #     queue = []
    #     while stack:
    #         node, node_prefix, level, is_tail = stack.pop()
    #         node_prefix = ("└── " if is_tail else "├── ")
    #         # print(child_prefix + " " * 8 * level + node_prefix + str(node.value))
    #         print(child_prefix + node_prefix + str(node.value))
    #         if node != None:
    #             if node.children:
    #                 # child_prefix = child_prefix + (" " * 8 if is_tail else "│" + " " * 6)
    #                 child_prefix = (" " * 8 * (level + 1) if is_tail else "│" + " " * 6)
    #                 child_count = len(node.children)
    #                 for i, child in enumerate(reversed(node.children)):
    #                     is_tail = (i == child_count - 1)
    #                     stack.append((child, child_prefix, level + 1, is_tail))
    #             stack.append((node, node_prefix, level, is_tail))
    #         else:
    #             node =;
    #             stack.pop()
    #     pass  # def

    def _distinguish_node_format(self, item: Union[str, Entity, None]):
        """
        判断输入的节点之输入格式。是以节点`id`还是节点实体本身的格式。然后返回节点实体本身。

        Args:
            item (Union[str, Entity]): 输入的节点。可以是`id`或者是节点实体本身。

        Returns:
            Entity: 节点实体本身。

        """

        if isinstance(item, str):
            node = self.get_node_by_id(item)
        elif isinstance(item, Entity):
            node = item
        else:
            node = None
            pass  # if
        if node is not None:
            return node
        else:
            logging.info(f"没有找到节点")
            return None
            pass  # if

        pass  # def

    def _distinguish_node_format_and_type(self, item: Union[str, Entity, None]):
        """
        判断输入的节点之输入格式与实体类型。是以节点`id`还是节点实体本身的格式，并且判断实体类型。然后返回节点实体本身。

        Args:
            item (Union[str, Entity]): 输入的节点。可以是树节点之`id`或者是树节点实体本身，也可以是算法节点之`id`或者是算法节点实体本身。

        Returns:
            Entity: 树节点实体本身，如果没有找到则返回`None`。

        """

        if isinstance(item, str):
            node_format = "id"
        elif isinstance(item, Entity):
            node_format = "entity"

        if node_format == "id":
            if item in EntityManager.treeEntities.keys():
                node = EntityManager.treeEntities[id]
                type_name = "树节点实体"
            else:
                for entity in EntityManager.entities.values():
                    if item == entity.attribute.id:
                        node = entity
                        type_name = "算法实体之节点实体"
                        break
                    else:
                        node = None
                    pass  # if
                pass  # for
            pass  # if

        if node_format == "entity":
            if item in EntityManager.treeEntities.values():
                node = item
                type_name = "树节点实体"
            elif item in EntityManager.entities.values():
                node = item
                type_name = "算法实体之节点实体"
            else:
                node = None
            pass

        if type_name == "树节点实体":
            result_node = node
        elif type_name == "算法实体之节点实体":
            ## 根据算法实体之节点实体获取树节点实体。
            for tree_entity in EntityManager.treeEntities.values():
                if node.attribute.id == tree_entity.content.attribute.id:
                    result_node = tree_entity
                    break
                else:
                    result_node = None
                pass

        if result_node is not None:
            logging.debug(f"通过{node_format}和{type_name}找到树节点：{node.attribute.entity_name}")
            return result_node
        else:
            logging.info(f"没有找到节点")
            return None
            pass  # if

    pass  # def


pass  # class

```



## 附录代码











### 从包批量导入模块与方法`import_modules_from_package.py`


```python
@classmethod  
def import_modules_from_package(cls, folderpath: str, pattern: str):  
"""  
从包批量导入模块与方法  
  
Args:  
folderpath: 包所在路径  
env: 环境变量  
  
Returns:  
env += env['list_entityData']  
"""  
  
# folderpath = cls._translate_package_form_path_to_folder_form_path(package_form_path) # NOTE 仅当如果用到以模块形式的包之路径的时候启用。  
module_form_path_package = cls._translate_folder_form_path_to_package_form_path(folderpath[0])  
  
## 遍历以导入内容函数  
idx_file = 0  
list_files = [] # 文件列表  
list_contents = {} # 内容列表  
  
for module_finder_01, name_01, is_pkg in pkgutil.walk_packages([folderpath[0].__str__()]):  
if is_pkg: # 如果路径下面还有一级子文件夹  
for module_finder_02, name_02, _ in pkgutil.iter_modules([Path(module_finder_01.path).joinpath(name_01).__str__()]):  
list_files.append(importlib.import_module("." + name_02, module_form_path_package + "." + Path(module_finder_02.path).name))  
if re.search(pattern, Path(list_files[idx_file].__str__()).name) is not None:  
for content in dir(list_files[idx_file]):  
if re.search(pattern, content.__str__()) is not None:  
list_contents.update({name_02: list_files[idx_file].__dict__.get(content)})  
idx_file += 1  
else: # 如果路径下面没有子文件夹  
# for module_finder, name_01, _ in pkgutil.iter_modules([folderpath[0].__str__()]):  
list_files.append(importlib.import_module("." + name_01, module_form_path_package))  
for content in dir(list_files[idx_file]):  
if not content.startswith("__"):  
list_contents.update({list_files[idx_file].__dict__.get(content)['attribute']['entity_name']: list_files[idx_file].__dict__.get(content)})  
idx_file += 1  
  
return list_contents
```
